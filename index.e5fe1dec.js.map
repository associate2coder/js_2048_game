{"mappings":"I,E,E,E,E,E,E,ECQM,EAGA,EACA,EAEA,EAUA,EA0BA,EAeA,EACA,EAEA,EAOA,EAeA,EAyDA,EAUA,EA2BA,EAeA,E,E,C,E,E,C,E,O,E,C,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,G,iB,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,E,E,S,E,E,S,E,E,S,E,E,SA/LA,EAAO,GCCb,CAAA,eEEoC,EFF9B,SAAA,IAeQ,IAAA,EAAA,UAAA,MAAA,CAAA,GAAA,AAAA,KAAA,IAAA,SAAA,CAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAe,AAAA,EAAA,OAAQ,CAAE,aAAa,CAf9C,ACTN,CAAA,SAA2B,CAAQ,CAAE,CAAW,EAC5C,GAAI,CAAE,CAAA,aAAoB,CAAA,EAAc,MAAM,AAAI,UAAU,oCAChE,CAAA,EDOM,IAAA,CAAA,GAgBF,IAAI,CAAC,WAAW,CAAG,CACjB,MAAO,EACP,MAAO,EACP,OAAQ,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,IAAI,CAC7B,aAAc,CAAA,EACd,MAAO,CACT,C,CAtBE,OEE8B,EFF9B,C,CAyBJ,IAAA,WAAA,MAAA,WACE,OAAO,IAAI,CAAC,IAAI,CAAC,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,IAAI,CAC3C,C,E,CACA,IAAA,YAAA,MAAA,WACE,OAAO,IAAI,CAAC,IAAI,CAAC,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,KAAK,CAC5C,C,E,CACA,IAAA,SAAA,MAAA,WACE,OAAO,IAAI,CAAC,IAAI,CAAC,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,EAAE,CACzC,C,E,CACA,IAAA,WAAA,MAAA,WACE,OAAO,IAAI,CAAC,IAAI,CAAC,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,IAAI,CAC3C,C,E,CAKA,IAAA,WAAA,MAAA,WACE,OA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","sources":["<anon>","src/scripts/main.js","src/modules/Game.class.js","node_modules/@swc/helpers/esm/_class_call_check.js","node_modules/@swc/helpers/esm/_create_class.js"],"sourcesContent":["(function () {\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire7b01\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire7b01\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $lRvfw = parcelRequire(\"lRvfw\");\n\nvar $8xYaD = parcelRequire(\"8xYaD\");\n\nvar $bs6f0 = parcelRequire(\"bs6f0\");\n\"use strict\";\nvar $3d28d7f1aac198f5$exports = {};\nfunction $8713978b2328d32b$export$71511d61b312f219(instance, Constructor) {\n    if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\n\nfunction $4fc75ccb937ab1df$var$_defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction $4fc75ccb937ab1df$export$71511d61b312f219(Constructor, protoProps, staticProps) {\n    if (protoProps) $4fc75ccb937ab1df$var$_defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) $4fc75ccb937ab1df$var$_defineProperties(Constructor, staticProps);\n    return Constructor;\n}\n\n\n\nvar $lRvfw = parcelRequire(\"lRvfw\");\n\"use strict\";\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */ var $3d28d7f1aac198f5$var$Game = /*#__PURE__*/ function() {\n    function Game() {\n        var initialState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (0, $lRvfw.default).INITIAL_STATE;\n        (0, $8713978b2328d32b$export$71511d61b312f219)(this, Game);\n        this.gameContext = {\n            state: initialState,\n            score: 0,\n            status: (0, $lRvfw.default).STATUS.idle,\n            movePossible: true,\n            moves: 0\n        };\n    }\n    (0, $4fc75ccb937ab1df$export$71511d61b312f219)(Game, [\n        {\n            key: \"moveLeft\",\n            value: function moveLeft() {\n                return this.move((0, $lRvfw.default).DIRECTION.left);\n            }\n        },\n        {\n            key: \"moveRight\",\n            value: function moveRight() {\n                return this.move((0, $lRvfw.default).DIRECTION.right);\n            }\n        },\n        {\n            key: \"moveUp\",\n            value: function moveUp() {\n                return this.move((0, $lRvfw.default).DIRECTION.up);\n            }\n        },\n        {\n            key: \"moveDown\",\n            value: function moveDown() {\n                return this.move((0, $lRvfw.default).DIRECTION.down);\n            }\n        },\n        {\n            /**\n   * @returns {number}\n   */ key: \"getScore\",\n            value: function getScore() {\n                return this.gameContext.score;\n            }\n        },\n        {\n            /**\n   * @returns {number[][]}\n   */ key: \"getState\",\n            value: function getState() {\n                return Array.from(this.gameContext.state).map(function(line) {\n                    return Array.from(line);\n                });\n            }\n        },\n        {\n            /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */ key: \"getStatus\",\n            value: function getStatus() {\n                return this.getGameContext().status;\n            }\n        },\n        {\n            /**\n   * Starts the game.\n   */ key: \"start\",\n            value: function start() {\n                this.updateGameContext({\n                    status: (0, $lRvfw.default).STATUS.playing\n                });\n                this.addRandomCellValue();\n                this.addRandomCellValue();\n            }\n        },\n        {\n            /**\n   * Resets the game.\n   */ key: \"restart\",\n            value: function restart() {\n                this.updateGameContext({\n                    score: 0,\n                    state: (0, $lRvfw.default).INITIAL_STATE,\n                    status: (0, $lRvfw.default).STATUS.playing\n                });\n                this.addRandomCellValue();\n                this.addRandomCellValue();\n            }\n        },\n        {\n            // Add your own methods here\n            /**\n   * Updates context with 'win' status\n   */ key: \"win\",\n            value: function win() {\n                this.updateGameContext({\n                    status: (0, $lRvfw.default).STATUS.win\n                });\n            }\n        },\n        {\n            /**\n   * Updates context with 'lose' status\n   */ key: \"lose\",\n            value: function lose() {\n                this.updateGameContext({\n                    status: (0, $lRvfw.default).STATUS.lose\n                });\n            }\n        },\n        {\n            /**\n   * returns number of moves made since start/restart of the game\n   * @returns {number}\n   */ key: \"getMoves\",\n            value: function getMoves() {\n                return this.getGameContext().moves;\n            }\n        },\n        {\n            /**\n   * returns game context contatining core stats of the game\n   * @returns {object}\n   */ key: \"getGameContext\",\n            value: function getGameContext() {\n                return this.gameContext;\n            }\n        },\n        {\n            /**\n   * function checks whether any particular tile can be moved in a position of\n   * the next tile in the direction of the move (or merged with it)\n   * @param {number} first\n   * @param {number} second\n   * @returns {boolean} true (if move or merge is possible), otherwise - false\n   */ key: \"canMoveOrMergeCells\",\n            value: function canMoveOrMergeCells(first, second) {\n                return first === 0 && second !== 0 || (first !== 0 || second !== 0) && first === second;\n            }\n        },\n        {\n            /**\n   * checks whether current state of the field has tiles with zero value.\n   * @returns {boolean}\n   */ key: \"stateHasZeroes\",\n            value: function stateHasZeroes() {\n                return this.getState().some(function(line) {\n                    return line.some(function(cell) {\n                        return cell === 0;\n                    });\n                });\n            }\n        },\n        {\n            /**\n   * checks whether current state of the field has at least\n   * one case of tiles that can be merged\n   * @returns {boolean}\n   */ key: \"mergeIsPossible\",\n            value: function mergeIsPossible() {\n                var state = this.getState();\n                for(var i = 0; i < state.length; i++)for(var j = 0; j < state[i].length; j++){\n                    var current = state[i][j];\n                    var right = state[i][j + 1];\n                    if (right && current === right) return true;\n                    if (i === state.length - 1) continue;\n                    var below = state[i + 1][j];\n                    if (below && current === below) return true;\n                }\n                return false;\n            }\n        },\n        {\n            /**\n   * Checks if the current state of the field has any moves available.\n   * @returns {boolean}\n   */ key: \"checkIfLost\",\n            value: function checkIfLost() {\n                return !this.stateHasZeroes() && !this.mergeIsPossible();\n            }\n        },\n        {\n            /**\n   * Checks whether any cell line (1d array) has any moves available.\n   * @param {number[][]} state\n   * @returns {boolean}\n   */ key: \"checkAvailableMovesOnSingleLine\",\n            value: function checkAvailableMovesOnSingleLine(state) {\n                for(var i = 0; i < state.length; i++)for(var j = 0; j < state[i].length - 1; j++){\n                    var first = state[i][j];\n                    var second = state[i][j + 1];\n                    if (this.canMoveOrMergeCells(first, second)) return true;\n                }\n                return false;\n            }\n        },\n        {\n            /**\n   * Method updates current state of the game context with new values\n   * @param {object} keyValuePairObj\n   */ key: \"updateGameContext\",\n            value: function updateGameContext(keyValuePairObj) {\n                var _this = this;\n                Object.entries(keyValuePairObj).forEach(function(entry) {\n                    var key = entry[0];\n                    var value = entry[1];\n                    _this.gameContext[key] = value;\n                });\n            }\n        },\n        {\n            /**\n   * @param {number[][]} state - some form of state of the field\n   * @returns {number[][]} copy of the state reversed horizontally\n   */ key: \"reverseStateByAxis\",\n            value: function reverseStateByAxis(state) {\n                return Array.from(state.map(function(line) {\n                    return Array.from(line).reverse();\n                }));\n            }\n        },\n        {\n            /**\n   * Function calls relevant functions which may need to\n   * transpose and/or reverses state of the field\n   * depending on direction of the move\n   * @param {number[][]} state - some form of state of the field\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {number[][]} copy of updated state of the field\n   */ key: \"transformStatePerDirection\",\n            value: function transformStatePerDirection(state, direction) {\n                switch(direction){\n                    case (0, $lRvfw.default).DIRECTION.left:\n                        return state;\n                    case (0, $lRvfw.default).DIRECTION.right:\n                        return this.reverseStateByAxis(state);\n                    case (0, $lRvfw.default).DIRECTION.up:\n                        return this.transposeState(state, false);\n                    case (0, $lRvfw.default).DIRECTION.down:\n                        return this.transposeState(state, true);\n                }\n            }\n        },\n        {\n            /**\n   * Function transposes rows of the state of the field into columns.\n   * If needed, function reverses the lines of the transposed field.\n   * @param {number[][]} state - some form of state of the field\n   * @param {boolean} reverse - whether the transposed field should be reversed.\n   * @returns copy of the transposed/reversed state of the field.\n   */ key: \"transposeState\",\n            value: function transposeState(state) {\n                var reverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n                var transposeState = Array.from(state).map(function(line) {\n                    return Array.from(line);\n                });\n                state.forEach(function(line, i) {\n                    line.forEach(function(cell, j) {\n                        transposeState[j][i] = cell;\n                    });\n                });\n                return reverse ? transposeState.reverse().map(function(line) {\n                    return line.reverse();\n                }) : transposeState;\n            }\n        },\n        {\n            /**\n   * Function removes zeroes from the state of the field.\n   * @param {number[][]} state - some form of the state of the field\n   * @returns {number[][]} - copy of the the field without zero valued tiles\n   */ key: \"removeZeroes\",\n            value: function removeZeroes(state) {\n                return Array.from(state).map(function(line) {\n                    return Array.from(line).filter(function(num) {\n                        return num !== 0;\n                    });\n                });\n            }\n        },\n        {\n            /**\n   * Functions adds zeroes to empty tiles (after moves and merges are complete)\n   * @param {number[][]} state - some form of the state of the field\n   * @returns {number[][]} - copy of the field filled with 0 valued cells\n   */ key: \"fillWithZeroes\",\n            value: function fillWithZeroes(state) {\n                return Array.from(state).map(function(line) {\n                    if (line.length < (0, $lRvfw.default).FIELD_SIZE) {\n                        var updatedLine = Array.from(line);\n                        updatedLine.length = (0, $lRvfw.default).FIELD_SIZE;\n                        return updatedLine.fill(0, line.length, (0, $lRvfw.default).FIELD_SIZE);\n                    } else return Array.from(line);\n                });\n            }\n        },\n        {\n            /**\n   * Function that processes:\n   * (1) move of non-zero tiles\n   * (2) merge of tiles\n   * (3) update score per turn\n   * (4) removes zeroes got as a result of merge\n   * @param {number[][]} state - some form of the field\n   * @returns {number[][]} - copy of the field with moved/merged cells\n   */ key: \"moveAndMergeTiles\",\n            value: function moveAndMergeTiles(state) {\n                var resultField = Array.from(state);\n                var score = 0;\n                for(var i = 0; i < state.length; i++)for(var j = 0; j < state[i].length - 1; j++){\n                    var current = state[i][j];\n                    var next = state[i][j + 1];\n                    if (current === 0) continue;\n                    if (current === next) {\n                        var mergeValue = current * 2;\n                        if (mergeValue === (0, $lRvfw.default).WIN_VALUE) this.updateGameContext({\n                            status: (0, $lRvfw.default).STATUS.win\n                        });\n                        score += mergeValue;\n                        resultField[i][j] = mergeValue;\n                        resultField[i][j + 1] = 0;\n                    }\n                }\n                var resultWithNoExtraZeroes = this.removeZeroes(resultField);\n                return {\n                    score: score,\n                    stateWithMergedTiles: resultWithNoExtraZeroes\n                };\n            }\n        },\n        {\n            /**\n   * Function that selects proper move function\n   * depending on the direction of the move\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {function}\n   */ key: \"selectMoveFunction\",\n            value: function selectMoveFunction(direction) {\n                var functions = {\n                    left: this.moveLeft.bind(this),\n                    right: this.moveRight.bind(this),\n                    up: this.moveUp.bind(this),\n                    down: this.moveDown.bind(this)\n                };\n                return functions[direction];\n            }\n        },\n        {\n            /**\n   * Function that coordinates the procedure of the move\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {boolean} true, if move succesfully processed\n   */ key: \"move\",\n            value: function move(direction) {\n                // transform state (per X and Y axis) into convenient rows\n                var transformedState = this.transformStatePerDirection(this.getState(), direction);\n                // if move is not possible, move is not processed\n                this.updateGameContext({\n                    movePossible: this.checkAvailableMovesOnSingleLine(transformedState)\n                });\n                if (!this.getGameContext().movePossible) return false;\n                // if move possible, remove zero tiles\n                var stateWithoutZeroes = this.removeZeroes(transformedState);\n                // merge tiles and calculate score\n                var _this_moveAndMergeTiles = this.moveAndMergeTiles(stateWithoutZeroes), score = _this_moveAndMergeTiles.score, stateWithMergedTiles = _this_moveAndMergeTiles.stateWithMergedTiles;\n                // empty tiles assigned with zero values\n                var updatedStateWithZeroes = this.fillWithZeroes(stateWithMergedTiles);\n                // re-transform X and Y axes back to their original state\n                var reTransformedState = this.transformStatePerDirection(updatedStateWithZeroes, direction);\n                // update game context with results of the move\n                this.updateGameContext({\n                    score: this.getScore() + score,\n                    state: reTransformedState,\n                    moves: this.getGameContext().moves += 1\n                });\n                return true;\n            }\n        },\n        {\n            /**\n   * Function checks whether 4 valued cell should be added\n   * with certain probability (currently 10%)\n   * @returns {boolean}\n   */ key: \"isTimeForFourTile\",\n            value: function isTimeForFourTile() {\n                return Math.random() < (0, $lRvfw.default).PROBABILITY_FOR_FOUR;\n            }\n        },\n        {\n            /**\n   *\n   * @param {number} number\n   * @param {number} probability - number between 0 and 1\n   * @returns\n   */ key: \"randomlyChangeNumberWithProbability\",\n            value: function randomlyChangeNumberWithProbability(number, probability) {\n                var random = Math.random();\n                return random < probability ? random : number;\n            }\n        },\n        {\n            /**\n   * Function analyses current state of the field and randomly adds\n   * a new cell with value of 2 (90% probability) or 4 (10% probability).\n   * Function is based on Reservoir Sampling algorithm.\n   * @returns {object} contains boolean field 'failedToAdd' and,\n   * in case of success, also contains row and col numbers and respective value.\n   */ key: \"addRandomCellValue\",\n            value: function addRandomCellValue() {\n                var state = this.getState();\n                var updatedField = Array.from(state).map(function(line) {\n                    return Array.from(line);\n                });\n                var count = 1;\n                var probability = function() {\n                    return 1 / count;\n                };\n                var row = -1;\n                var col = -1;\n                var referenceRandom = -1;\n                for(var i = 0; i < state.length; i++)for(var j = 0; j < state[i].length; j++){\n                    if (state[i][j] !== 0) continue;\n                    var random = this.randomlyChangeNumberWithProbability(referenceRandom, probability());\n                    if (random !== referenceRandom) {\n                        referenceRandom = random;\n                        row = i;\n                        col = j;\n                    }\n                    count++;\n                }\n                if (row === -1 || col === -1 || updatedField[row][col] === undefined) return {\n                    failedToAdd: true\n                };\n                var value = this.isTimeForFourTile() ? 4 : 2;\n                if (updatedField[row][col] === 0) {\n                    updatedField[row][col] = value;\n                    this.updateGameContext({\n                        state: updatedField\n                    });\n                    return {\n                        failedToAdd: false,\n                        row: row,\n                        col: col,\n                        value: value\n                    };\n                }\n                return {\n                    failedToAdd: true\n                };\n            }\n        }\n    ]);\n    return Game;\n}();\n$3d28d7f1aac198f5$exports = $3d28d7f1aac198f5$var$Game;\n\n\nvar $197cd56b15c33885$var$game = new $3d28d7f1aac198f5$exports();\n// Write your code here\nvar $197cd56b15c33885$var$gameField = document.querySelector(\".game-field\");\nvar $197cd56b15c33885$var$scoreField = document.querySelector(\".game-score\");\nvar $197cd56b15c33885$var$resetCellClassName = function(cell) {\n    var classList = cell.classList;\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = classList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var item = _step.value;\n            if (item !== \"field-cell\") cell.classList.remove(item);\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n};\nvar $197cd56b15c33885$var$renderBoard = function() {\n    var state = $197cd56b15c33885$var$game.getState();\n    var rows = $197cd56b15c33885$var$gameField.rows;\n    for(var i = 0; i < state.length; i++){\n        var fieldRow = rows[i].cells;\n        var stateRow = state[i];\n        for(var j = 0; j < fieldRow.length; j++){\n            var newValue = stateRow[j];\n            var cell = fieldRow[j];\n            $197cd56b15c33885$var$resetCellClassName(cell);\n            if (newValue !== 0) {\n                cell.innerHTML = newValue;\n                cell.classList.add(\"field-cell--\" + newValue);\n            } else cell.innerHTML = \"\";\n        }\n    }\n    $197cd56b15c33885$var$scoreField.innerHTML = $197cd56b15c33885$var$game.getScore();\n};\nvar $197cd56b15c33885$var$renderCell = function(AddNewCellResult) {\n    var failedToAdd = AddNewCellResult.failedToAdd, row = AddNewCellResult.row, col = AddNewCellResult.col, value = AddNewCellResult.value;\n    if (failedToAdd) return;\n    var cell = $197cd56b15c33885$var$gameField.rows[row].cells[col];\n    if (cell) {\n        cell.innerHTML = value;\n        cell.classList.add(\"field-cell--\" + value);\n    }\n};\nvar $197cd56b15c33885$var$startButton = document.querySelector(\".start\");\nvar $197cd56b15c33885$var$restartButton = document.querySelector(\".restart\");\nvar $197cd56b15c33885$var$modificationsAfterFirstMove = function() {\n    // change buttons to restart\n    (0, $bs6f0.default).switchButtons(\".restart\");\n    // change message to restart\n    (0, $bs6f0.default).makeMessageVisible(\".message-restart\");\n};\nvar $197cd56b15c33885$var$handleEndGameEvent = function(gameStatus) {\n    if (gameStatus === (0, $lRvfw.default).STATUS.win) (0, $bs6f0.default).makeMessageVisible(\".message-win\");\n    if (gameStatus === (0, $lRvfw.default).STATUS.lose) (0, $bs6f0.default).makeMessageVisible(\".message-lose\");\n    if (gameStatus !== (0, $lRvfw.default).STATUS.playing) (0, $bs6f0.default).defocusField();\n    $197cd56b15c33885$var$removeMoveEventListeners();\n};\nvar $197cd56b15c33885$var$handleMoveEvent = function(direction) {\n    if ($197cd56b15c33885$var$game.getStatus() === (0, $lRvfw.default).STATUS.win || $197cd56b15c33885$var$game.getStatus() === (0, $lRvfw.default).STATUS.lose) return;\n    var promise = new Promise(function(resolve, reject) {\n        if ($197cd56b15c33885$var$game.checkIfLost()) reject(new Error((0, $lRvfw.default).STATUS.lose));\n        var moveFunction = $197cd56b15c33885$var$game.selectMoveFunction(direction);\n        var moveProcessed = moveFunction();\n        if (moveProcessed) resolve(\"Moved\");\n        else reject(new Error(\"Move failed\"));\n    });\n    promise.then(function(message) {\n        // eslint-disable-next-line no-console\n        console.log(message);\n        $197cd56b15c33885$var$renderBoard();\n        if ($197cd56b15c33885$var$game.getMoves() === 1) $197cd56b15c33885$var$modificationsAfterFirstMove();\n        if ($197cd56b15c33885$var$game.getStatus() === (0, $lRvfw.default).STATUS.win) {\n            $197cd56b15c33885$var$handleEndGameEvent((0, $lRvfw.default).STATUS.win);\n            return;\n        }\n        setTimeout(function() {\n            return $197cd56b15c33885$var$renderCell($197cd56b15c33885$var$game.addRandomCellValue());\n        }, 300);\n    }).catch(function(err) {\n        // eslint-disable-next-line no-console\n        console.log({\n            err: err\n        });\n        if (err.message === (0, $lRvfw.default).STATUS.lose) $197cd56b15c33885$var$handleEndGameEvent((0, $lRvfw.default).STATUS.lose);\n        if (err.message === \"Move failed\") // eslint-disable-next-line no-console\n        console.log(err.message);\n    });\n};\nvar $197cd56b15c33885$var$handleKeyDownEvent = function(e) {\n    var targetKey = e.key;\n    if (targetKey && (0, $8xYaD.keyController).arrowKeys.hasOwnProperty(targetKey)) {\n        var direction = (0, $8xYaD.keyController).identifyArrowKeyDirection(targetKey);\n        $197cd56b15c33885$var$handleMoveEvent(direction);\n    }\n};\nvar $197cd56b15c33885$var$handleSwipeEvent = function(e) {\n    var direction = (0, $8xYaD.swipeController).handleTouchEnd(e);\n    $197cd56b15c33885$var$handleMoveEvent(direction);\n};\nvar $197cd56b15c33885$var$handleStartEvent = function() {\n    if ($197cd56b15c33885$var$game.getStatus() === (0, $lRvfw.default).STATUS.playing) return;\n    $197cd56b15c33885$var$addMoveEventListeners();\n    $197cd56b15c33885$var$game.start();\n    (0, $bs6f0.default).focusField();\n    $197cd56b15c33885$var$renderBoard();\n};\nvar $197cd56b15c33885$var$handleRestartEvent = function() {\n    $197cd56b15c33885$var$removeMoveEventListeners();\n    $197cd56b15c33885$var$addMoveEventListeners();\n    (0, $bs6f0.default).makeMessageVisible(\".message-restart\");\n    $197cd56b15c33885$var$game.restart();\n    $197cd56b15c33885$var$renderBoard();\n    (0, $bs6f0.default).focusField();\n};\nvar $197cd56b15c33885$var$addMoveEventListeners = function() {\n    document.addEventListener(\"keydown\", $197cd56b15c33885$var$handleKeyDownEvent);\n    $197cd56b15c33885$var$gameField.addEventListener(\"touchstart\", (0, $8xYaD.swipeController).handleTouchStart.bind((0, $8xYaD.swipeController)));\n    $197cd56b15c33885$var$gameField.addEventListener(\"touchend\", $197cd56b15c33885$var$handleSwipeEvent);\n    $197cd56b15c33885$var$gameField.addEventListener(\"touchmove\", (0, $8xYaD.swipeController).preventScrollOnSwipe.bind((0, $8xYaD.swipeController)));\n};\nvar $197cd56b15c33885$var$removeMoveEventListeners = function() {\n    document.removeEventListener(\"keydown\", $197cd56b15c33885$var$handleKeyDownEvent);\n    $197cd56b15c33885$var$gameField.removeEventListener(\"touchstart\", (0, $8xYaD.swipeController).handleTouchStart.bind((0, $8xYaD.swipeController)));\n    $197cd56b15c33885$var$gameField.removeEventListener(\"touchend\", $197cd56b15c33885$var$handleSwipeEvent);\n    $197cd56b15c33885$var$gameField.removeEventListener(\"touchmove\", (0, $8xYaD.swipeController).preventScrollOnSwipe.bind((0, $8xYaD.swipeController)));\n};\n$197cd56b15c33885$var$startButton.addEventListener(\"click\", $197cd56b15c33885$var$handleStartEvent);\n$197cd56b15c33885$var$restartButton.addEventListener(\"click\", $197cd56b15c33885$var$handleRestartEvent);\n\n})();\n//# sourceMappingURL=index.e5fe1dec.js.map\n","'use strict';\n\nimport constants from './constants.js';\nimport { keyController, swipeController } from './keySwipeController.js';\nimport statusVisibilityController from './statusVisibilityController.js';\n\n// Uncomment the next lines to use your game instance in the browser\nconst Game = require('../modules/Game.class');\nconst game = new Game();\n\n// Write your code here\nconst gameField = document.querySelector('.game-field');\nconst scoreField = document.querySelector('.game-score');\n\nconst resetCellClassName = (cell) => {\n  const classList = cell.classList;\n\n  for (const item of classList) {\n    if (item !== 'field-cell') {\n      cell.classList.remove(item);\n    }\n  }\n};\n\nconst renderBoard = () => {\n  const state = game.getState();\n\n  const rows = gameField.rows;\n\n  for (let i = 0; i < state.length; i++) {\n    const fieldRow = rows[i].cells;\n    const stateRow = state[i];\n\n    for (let j = 0; j < fieldRow.length; j++) {\n      const newValue = stateRow[j];\n      const cell = fieldRow[j];\n\n      resetCellClassName(cell);\n\n      if (newValue !== 0) {\n        cell.innerHTML = newValue;\n        cell.classList.add('field-cell--' + newValue);\n      } else {\n        cell.innerHTML = '';\n      }\n    }\n  }\n  scoreField.innerHTML = game.getScore();\n};\n\nconst renderCell = (AddNewCellResult) => {\n  const { failedToAdd, row, col, value } = AddNewCellResult;\n\n  if (failedToAdd) {\n    return;\n  }\n\n  const cell = gameField.rows[row].cells[col];\n\n  if (cell) {\n    cell.innerHTML = value;\n    cell.classList.add('field-cell--' + value);\n  }\n};\n\nconst startButton = document.querySelector('.start');\nconst restartButton = document.querySelector('.restart');\n\nconst modificationsAfterFirstMove = () => {\n  // change buttons to restart\n  statusVisibilityController.switchButtons('.restart');\n  // change message to restart\n  statusVisibilityController.makeMessageVisible('.message-restart');\n};\n\nconst handleEndGameEvent = (gameStatus) => {\n  if (gameStatus === constants.STATUS.win) {\n    statusVisibilityController.makeMessageVisible('.message-win');\n  }\n\n  if (gameStatus === constants.STATUS.lose) {\n    statusVisibilityController.makeMessageVisible('.message-lose');\n  }\n\n  if (gameStatus !== constants.STATUS.playing) {\n    statusVisibilityController.defocusField();\n  }\n  removeMoveEventListeners();\n};\n\nconst handleMoveEvent = (direction) => {\n  if (\n    game.getStatus() === constants.STATUS.win ||\n    game.getStatus() === constants.STATUS.lose\n  ) {\n    return;\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    if (game.checkIfLost()) {\n      reject(new Error(constants.STATUS.lose));\n    }\n\n    const moveFunction = game.selectMoveFunction(direction);\n    const moveProcessed = moveFunction();\n\n    if (moveProcessed) {\n      resolve('Moved');\n    } else {\n      reject(new Error('Move failed'));\n    }\n  });\n\n  promise\n    .then((message) => {\n      // eslint-disable-next-line no-console\n      console.log(message);\n\n      renderBoard();\n\n      if (game.getMoves() === 1) {\n        modificationsAfterFirstMove();\n      }\n\n      if (game.getStatus() === constants.STATUS.win) {\n        handleEndGameEvent(constants.STATUS.win);\n\n        return;\n      }\n\n      setTimeout(() => renderCell(game.addRandomCellValue()), 300);\n    })\n    .catch((err) => {\n      // eslint-disable-next-line no-console\n      console.log({ err });\n\n      if (err.message === constants.STATUS.lose) {\n        handleEndGameEvent(constants.STATUS.lose);\n      }\n\n      if (err.message === 'Move failed') {\n        // eslint-disable-next-line no-console\n        console.log(err.message);\n      }\n    });\n};\n\nconst handleKeyDownEvent = (e) => {\n  const targetKey = e.key;\n\n  if (targetKey && keyController.arrowKeys.hasOwnProperty(targetKey)) {\n    const direction = keyController.identifyArrowKeyDirection(targetKey);\n\n    handleMoveEvent(direction);\n  }\n};\n\nconst handleSwipeEvent = (e) => {\n  const direction = swipeController.handleTouchEnd(e);\n\n  handleMoveEvent(direction);\n};\n\nconst handleStartEvent = () => {\n  if (game.getStatus() === constants.STATUS.playing) {\n    return;\n  }\n\n  addMoveEventListeners();\n\n  game.start();\n  statusVisibilityController.focusField();\n  renderBoard();\n};\n\nconst handleRestartEvent = () => {\n  removeMoveEventListeners();\n  addMoveEventListeners();\n  statusVisibilityController.makeMessageVisible('.message-restart');\n  game.restart();\n  renderBoard();\n  statusVisibilityController.focusField();\n};\n\nconst addMoveEventListeners = () => {\n  document.addEventListener('keydown', handleKeyDownEvent);\n\n  gameField.addEventListener(\n    'touchstart',\n    swipeController.handleTouchStart.bind(swipeController),\n  );\n  gameField.addEventListener('touchend', handleSwipeEvent);\n\n  gameField.addEventListener(\n    'touchmove',\n    swipeController.preventScrollOnSwipe.bind(swipeController),\n  );\n};\n\nconst removeMoveEventListeners = () => {\n  document.removeEventListener('keydown', handleKeyDownEvent);\n\n  gameField.removeEventListener(\n    'touchstart',\n    swipeController.handleTouchStart.bind(swipeController),\n  );\n  gameField.removeEventListener('touchend', handleSwipeEvent);\n\n  gameField.removeEventListener(\n    'touchmove',\n    swipeController.preventScrollOnSwipe.bind(swipeController),\n  );\n};\n\nstartButton.addEventListener('click', handleStartEvent);\n\nrestartButton.addEventListener('click', handleRestartEvent);\n","'use strict';\n\nimport constants from '../scripts/constants.js';\n\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */\nclass Game {\n  /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */\n  constructor(initialState = constants.INITIAL_STATE) {\n    this.gameContext = {\n      state: initialState,\n      score: 0,\n      status: constants.STATUS.idle,\n      movePossible: true,\n      moves: 0,\n    };\n  }\n\n  moveLeft() {\n    return this.move(constants.DIRECTION.left);\n  }\n  moveRight() {\n    return this.move(constants.DIRECTION.right);\n  }\n  moveUp() {\n    return this.move(constants.DIRECTION.up);\n  }\n  moveDown() {\n    return this.move(constants.DIRECTION.down);\n  }\n\n  /**\n   * @returns {number}\n   */\n  getScore() {\n    return this.gameContext.score;\n  }\n\n  /**\n   * @returns {number[][]}\n   */\n  getState() {\n    return Array.from(this.gameContext.state).map((line) => Array.from(line));\n  }\n\n  /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */\n  getStatus() {\n    return this.getGameContext().status;\n  }\n\n  /**\n   * Starts the game.\n   */\n  start() {\n    this.updateGameContext({ status: constants.STATUS.playing });\n    this.addRandomCellValue();\n    this.addRandomCellValue();\n  }\n\n  /**\n   * Resets the game.\n   */\n  restart() {\n    this.updateGameContext({\n      score: 0,\n      state: constants.INITIAL_STATE,\n      status: constants.STATUS.playing,\n    });\n    this.addRandomCellValue();\n    this.addRandomCellValue();\n  }\n\n  // Add your own methods here\n  /**\n   * Updates context with 'win' status\n   */\n  win() {\n    this.updateGameContext({ status: constants.STATUS.win });\n  }\n\n  /**\n   * Updates context with 'lose' status\n   */\n  lose() {\n    this.updateGameContext({ status: constants.STATUS.lose });\n  }\n\n  /**\n   * returns number of moves made since start/restart of the game\n   * @returns {number}\n   */\n  getMoves() {\n    return this.getGameContext().moves;\n  }\n\n  /**\n   * returns game context contatining core stats of the game\n   * @returns {object}\n   */\n  getGameContext() {\n    return this.gameContext;\n  }\n\n  /**\n   * function checks whether any particular tile can be moved in a position of\n   * the next tile in the direction of the move (or merged with it)\n   * @param {number} first\n   * @param {number} second\n   * @returns {boolean} true (if move or merge is possible), otherwise - false\n   */\n  canMoveOrMergeCells(first, second) {\n    return (\n      (first === 0 && second !== 0) ||\n      ((first !== 0 || second !== 0) && first === second)\n    );\n  }\n\n  /**\n   * checks whether current state of the field has tiles with zero value.\n   * @returns {boolean}\n   */\n  stateHasZeroes() {\n    return this.getState().some((line) => {\n      return line.some((cell) => cell === 0);\n    });\n  }\n\n  /**\n   * checks whether current state of the field has at least\n   * one case of tiles that can be merged\n   * @returns {boolean}\n   */\n  mergeIsPossible() {\n    const state = this.getState();\n\n    for (let i = 0; i < state.length; i++) {\n      for (let j = 0; j < state[i].length; j++) {\n        const current = state[i][j];\n        const right = state[i][j + 1];\n\n        if (right && current === right) {\n          return true;\n        }\n\n        if (i === state.length - 1) {\n          continue;\n        }\n\n        const below = state[i + 1][j];\n\n        if (below && current === below) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks if the current state of the field has any moves available.\n   * @returns {boolean}\n   */\n  checkIfLost() {\n    return !this.stateHasZeroes() && !this.mergeIsPossible();\n  }\n\n  /**\n   * Checks whether any cell line (1d array) has any moves available.\n   * @param {number[][]} state\n   * @returns {boolean}\n   */\n  checkAvailableMovesOnSingleLine(state) {\n    for (let i = 0; i < state.length; i++) {\n      for (let j = 0; j < state[i].length - 1; j++) {\n        const first = state[i][j];\n        const second = state[i][j + 1];\n\n        if (this.canMoveOrMergeCells(first, second)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Method updates current state of the game context with new values\n   * @param {object} keyValuePairObj\n   */\n  updateGameContext(keyValuePairObj) {\n    Object.entries(keyValuePairObj).forEach((entry) => {\n      const key = entry[0];\n      const value = entry[1];\n\n      this.gameContext[key] = value;\n    });\n  }\n\n  /**\n   * @param {number[][]} state - some form of state of the field\n   * @returns {number[][]} copy of the state reversed horizontally\n   */\n  reverseStateByAxis(state) {\n    return Array.from(state.map((line) => Array.from(line).reverse()));\n  }\n\n  /**\n   * Function calls relevant functions which may need to\n   * transpose and/or reverses state of the field\n   * depending on direction of the move\n   * @param {number[][]} state - some form of state of the field\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {number[][]} copy of updated state of the field\n   */\n  transformStatePerDirection(state, direction) {\n    switch (direction) {\n      case constants.DIRECTION.left: {\n        return state;\n      }\n\n      case constants.DIRECTION.right: {\n        return this.reverseStateByAxis(state);\n      }\n\n      case constants.DIRECTION.up: {\n        return this.transposeState(state, false);\n      }\n\n      case constants.DIRECTION.down: {\n        return this.transposeState(state, true);\n      }\n    }\n  }\n\n  /**\n   * Function transposes rows of the state of the field into columns.\n   * If needed, function reverses the lines of the transposed field.\n   * @param {number[][]} state - some form of state of the field\n   * @param {boolean} reverse - whether the transposed field should be reversed.\n   * @returns copy of the transposed/reversed state of the field.\n   */\n  transposeState(state, reverse = false) {\n    const transposeState = Array.from(state).map((line) => Array.from(line));\n\n    state.forEach((line, i) => {\n      line.forEach((cell, j) => {\n        transposeState[j][i] = cell;\n      });\n    });\n\n    return reverse\n      ? transposeState.reverse().map((line) => line.reverse())\n      : transposeState;\n  }\n\n  /**\n   * Function removes zeroes from the state of the field.\n   * @param {number[][]} state - some form of the state of the field\n   * @returns {number[][]} - copy of the the field without zero valued tiles\n   */\n  removeZeroes(state) {\n    return Array.from(state).map((line) => {\n      return Array.from(line).filter((num) => num !== 0);\n    });\n  }\n\n  /**\n   * Functions adds zeroes to empty tiles (after moves and merges are complete)\n   * @param {number[][]} state - some form of the state of the field\n   * @returns {number[][]} - copy of the field filled with 0 valued cells\n   */\n  fillWithZeroes(state) {\n    return Array.from(state).map((line) => {\n      if (line.length < constants.FIELD_SIZE) {\n        const updatedLine = Array.from(line);\n\n        updatedLine.length = constants.FIELD_SIZE;\n\n        return updatedLine.fill(0, line.length, constants.FIELD_SIZE);\n      } else {\n        return Array.from(line);\n      }\n    });\n  }\n\n  /**\n   * Function that processes:\n   * (1) move of non-zero tiles\n   * (2) merge of tiles\n   * (3) update score per turn\n   * (4) removes zeroes got as a result of merge\n   * @param {number[][]} state - some form of the field\n   * @returns {number[][]} - copy of the field with moved/merged cells\n   */\n  moveAndMergeTiles(state) {\n    const resultField = Array.from(state);\n    let score = 0;\n\n    for (let i = 0; i < state.length; i++) {\n      for (let j = 0; j < state[i].length - 1; j++) {\n        const current = state[i][j];\n        const next = state[i][j + 1];\n\n        if (current === 0) {\n          continue;\n        }\n\n        if (current === next) {\n          const mergeValue = current * 2;\n\n          if (mergeValue === constants.WIN_VALUE) {\n            this.updateGameContext({ status: constants.STATUS.win });\n          }\n\n          score += mergeValue;\n          resultField[i][j] = mergeValue;\n          resultField[i][j + 1] = 0;\n        }\n      }\n    }\n\n    const resultWithNoExtraZeroes = this.removeZeroes(resultField);\n\n    return { score: score, stateWithMergedTiles: resultWithNoExtraZeroes };\n  }\n\n  /**\n   * Function that selects proper move function\n   * depending on the direction of the move\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {function}\n   */\n  selectMoveFunction(direction) {\n    const functions = {\n      left: this.moveLeft.bind(this),\n      right: this.moveRight.bind(this),\n      up: this.moveUp.bind(this),\n      down: this.moveDown.bind(this),\n    };\n\n    return functions[direction];\n  }\n\n  /**\n   * Function that coordinates the procedure of the move\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {boolean} true, if move succesfully processed\n   */\n  move(direction) {\n    // transform state (per X and Y axis) into convenient rows\n    const transformedState = this.transformStatePerDirection(\n      this.getState(),\n      direction,\n    );\n\n    // if move is not possible, move is not processed\n    this.updateGameContext({\n      movePossible: this.checkAvailableMovesOnSingleLine(transformedState),\n    });\n\n    if (!this.getGameContext().movePossible) {\n      return false;\n    }\n\n    // if move possible, remove zero tiles\n    const stateWithoutZeroes = this.removeZeroes(transformedState);\n\n    // merge tiles and calculate score\n    const { score, stateWithMergedTiles } =\n      this.moveAndMergeTiles(stateWithoutZeroes);\n\n    // empty tiles assigned with zero values\n    const updatedStateWithZeroes = this.fillWithZeroes(stateWithMergedTiles);\n\n    // re-transform X and Y axes back to their original state\n    const reTransformedState = this.transformStatePerDirection(\n      updatedStateWithZeroes,\n      direction,\n    );\n\n    // update game context with results of the move\n    this.updateGameContext({\n      score: this.getScore() + score,\n      state: reTransformedState,\n      moves: (this.getGameContext().moves += 1),\n    });\n\n    return true;\n  }\n\n  /**\n   * Function checks whether 4 valued cell should be added\n   * with certain probability (currently 10%)\n   * @returns {boolean}\n   */\n  isTimeForFourTile() {\n    return Math.random() < constants.PROBABILITY_FOR_FOUR;\n  }\n\n  /**\n   *\n   * @param {number} number\n   * @param {number} probability - number between 0 and 1\n   * @returns\n   */\n  randomlyChangeNumberWithProbability(number, probability) {\n    const random = Math.random();\n\n    return random < probability ? random : number;\n  }\n\n  /**\n   * Function analyses current state of the field and randomly adds\n   * a new cell with value of 2 (90% probability) or 4 (10% probability).\n   * Function is based on Reservoir Sampling algorithm.\n   * @returns {object} contains boolean field 'failedToAdd' and,\n   * in case of success, also contains row and col numbers and respective value.\n   */\n  addRandomCellValue() {\n    const state = this.getState();\n    const updatedField = Array.from(state).map((line) => Array.from(line));\n\n    let count = 1;\n    const probability = () => 1 / count;\n    let row = -1;\n    let col = -1;\n    let referenceRandom = -1;\n\n    for (let i = 0; i < state.length; i++) {\n      for (let j = 0; j < state[i].length; j++) {\n        if (state[i][j] !== 0) {\n          continue;\n        }\n\n        const random = this.randomlyChangeNumberWithProbability(\n          referenceRandom,\n          probability(),\n        );\n\n        if (random !== referenceRandom) {\n          referenceRandom = random;\n          row = i;\n          col = j;\n        }\n\n        count++;\n      }\n    }\n\n    if (row === -1 || col === -1 || updatedField[row][col] === undefined) {\n      return { failedToAdd: true };\n    }\n\n    const value = this.isTimeForFourTile() ? 4 : 2;\n\n    if (updatedField[row][col] === 0) {\n      updatedField[row][col] = value;\n      this.updateGameContext({ state: updatedField });\n\n      return {\n        failedToAdd: false,\n        row: row,\n        col: col,\n        value: value,\n      };\n    }\n\n    return { failedToAdd: true };\n  }\n}\n\nmodule.exports = Game;\n","function _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n}\nexport { _class_call_check as _ };\n","function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n\n        if (\"value\" in descriptor) descriptor.writable = true;\n\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n\n    return Constructor;\n}\nexport { _create_class as _ };\n"],"names":["$parcel$global","$parcel$modules","$parcel$inits","parcelRequire","$8xYaD","$bs6f0","$lRvfw","$197cd56b15c33885$var$game","$197cd56b15c33885$var$gameField","$197cd56b15c33885$var$scoreField","$197cd56b15c33885$var$resetCellClassName","$197cd56b15c33885$var$renderBoard","$197cd56b15c33885$var$renderCell","$197cd56b15c33885$var$startButton","$197cd56b15c33885$var$restartButton","$197cd56b15c33885$var$modificationsAfterFirstMove","$197cd56b15c33885$var$handleEndGameEvent","$197cd56b15c33885$var$handleMoveEvent","$197cd56b15c33885$var$handleKeyDownEvent","$197cd56b15c33885$var$handleSwipeEvent","$197cd56b15c33885$var$addMoveEventListeners","$197cd56b15c33885$var$removeMoveEventListeners","globalThis","self","window","global","id","exports","init","module","call","err","Error","code","register","protoProps","Game","initialState","arguments","length","default","INITIAL_STATE","instance","Constructor","TypeError","gameContext","state","score","status","STATUS","idle","movePossible","moves","key","value","move","DIRECTION","left","right","up","down","Array","from","map","line","getGameContext","updateGameContext","playing","addRandomCellValue","win","lose","first","second","getState","some","cell","i","j","current","below","stateHasZeroes","mergeIsPossible","canMoveOrMergeCells","keyValuePairObj","_this","Object","entries","forEach","entry","reverse","direction","reverseStateByAxis","transposeState","filter","num","FIELD_SIZE","updatedLine","fill","resultField","next","mergeValue","WIN_VALUE","stateWithMergedTiles","removeZeroes","functions","moveLeft","bind","moveRight","moveUp","moveDown","transformedState","transformStatePerDirection","checkAvailableMovesOnSingleLine","stateWithoutZeroes","_this_moveAndMergeTiles","moveAndMergeTiles","updatedStateWithZeroes","fillWithZeroes","reTransformedState","getScore","Math","random","PROBABILITY_FOR_FOUR","number","probability","updatedField","count","row","col","referenceRandom","randomlyChangeNumberWithProbability","undefined","failedToAdd","isTimeForFourTile","$4fc75ccb937ab1df$var$_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","prototype","document","querySelector","classList","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","item","remove","return","rows","fieldRow","cells","stateRow","newValue","innerHTML","add","AddNewCellResult","switchButtons","makeMessageVisible","gameStatus","defocusField","getStatus","promise","Promise","resolve","reject","checkIfLost","moveFunction","selectMoveFunction","then","message","console","log","getMoves","setTimeout","catch","e","targetKey","keyController","arrowKeys","hasOwnProperty","identifyArrowKeyDirection","swipeController","handleTouchEnd","addEventListener","handleTouchStart","preventScrollOnSwipe","removeEventListener","start","focusField","restart"],"version":3,"file":"index.e5fe1dec.js.map"}