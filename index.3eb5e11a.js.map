{"mappings":"A,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,I,E,E,S,E,E,S,E,E,S,E,E,SCQA,MAAM,EAAO,ICCb,MAeE,YAAY,EAAe,AAAA,EAAA,OAAQ,CAAE,aAAa,CAAE,CAClD,IAAI,CAAC,WAAW,CAAG,CACjB,MAAO,EACP,MAAO,EACP,OAAQ,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,IAAI,CAC7B,aAAc,CAAA,EACd,MAAO,CACT,CACF,CAEA,UAAW,CACT,OAAO,IAAI,CAAC,IAAI,CAAC,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,IAAI,CAC3C,CACA,WAAY,CACV,OAAO,IAAI,CAAC,IAAI,CAAC,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,KAAK,CAC5C,CACA,QAAS,CACP,OAAO,IAAI,CAAC,IAAI,CAAC,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,EAAE,CACzC,CACA,UAAW,CACT,OAAO,IAAI,CAAC,IAAI,CAAC,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,IAAI,CAC3C,CAKA,UAAW,CACT,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,AAC/B,CAKA,UAAW,CACT,OAAO,MAAM,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,GAAG,CAAC,AAAC,GAAS,MAAM,IAAI,CAAC,GACrE,CAYA,WAAY,CACV,OAAO,IAAI,CAAC,cAAc,GAAG,MAAM,AACrC,CAKA,OAAQ,CACN,IAAI,CAAC,iBAAiB,CAAC,CAAE,OAAQ,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,OAAO,AAAC,GAC1D,IAAI,CAAC,kBAAkB,GACvB,IAAI,CAAC,kBAAkB,EACzB,CAKA,SAAU,CACR,IAAI,CAAC,iBAAiB,CAAC,CACrB,MAAO,EACP,MAAO,AAAA,EAAA,OAAQ,CAAE,aAAa,CAC9B,OAAQ,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,OAAO,AAClC,GACA,IAAI,CAAC,kBAAkB,GACvB,IAAI,CAAC,kBAAkB,EACzB,CAMA,KAAM,CACJ,IAAI,CAAC,iBAAiB,CAAC,CAAE,OAAQ,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,GAAG,AAAC,EACxD,CAKA,MAAO,CACL,IAAI,CAAC,iBAAiB,CAAC,CAAE,OAAQ,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,IAAI,AAAC,EACzD,CAMA,UAAW,CACT,OAAO,IAAI,CAAC,cAAc,GAAG,KAAK,AACpC,CAMA,gBAAiB,CACf,OAAO,IAAI,CAAC,WAAW,AACzB,CASA,oBAAoB,CAAK,CAAE,CAAM,CAAE,CACjC,OACE,AAAW,IAAX,GAAgB,AAAW,IAAX,GACd,AAAA,CAAA,AAAU,IAAV,GAAe,AAAW,IAAX,CAAW,GAAM,IAAU,CAEhD,CAMA,gBAAiB,CACf,OAAO,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,AAAC,GACpB,EAAK,IAAI,CAAC,AAAC,GAAS,AAAS,IAAT,GAE/B,CAOA,iBAAkB,CAChB,IAAM,EAAQ,IAAI,CAAC,QAAQ,GAE3B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAChC,IAAK,IAAI,EAAI,EAAG,EAAI,CAAK,CAAC,EAAE,CAAC,MAAM,CAAE,IAAK,CACxC,IAAM,EAAU,CAAK,CAAC,EAAE,CAAC,EAAE,CACrB,EAAQ,CAAK,CAAC,EAAE,CAAC,EAAI,EAAE,CAE7B,GAAI,GAAS,IAAY,EACvB,MAAO,CAAA,EAGT,GAAI,IAAM,EAAM,MAAM,CAAG,EACvB,SAGF,IAAM,EAAQ,CAAK,CAAC,EAAI,EAAE,CAAC,EAAE,CAE7B,GAAI,GAAS,IAAY,EACvB,MAAO,CAAA,CAEX,CAGF,MAAO,CAAA,CACT,CAMA,aAAc,CACZ,MAAO,CAAC,IAAI,CAAC,cAAc,IAAM,CAAC,IAAI,CAAC,eAAe,EACxD,CAOA,gCAAgC,CAAK,CAAE,CACrC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAChC,IAAK,IAAI,EAAI,EAAG,EAAI,CAAK,CAAC,EAAE,CAAC,MAAM,CAAG,EAAG,IAAK,CAC5C,IAAM,EAAQ,CAAK,CAAC,EAAE,CAAC,EAAE,CACnB,EAAS,CAAK,CAAC,EAAE,CAAC,EAAI,EAAE,CAE9B,GAAI,IAAI,CAAC,mBAAmB,CAAC,EAAO,GAClC,MAAO,CAAA,CAEX,CAGF,MAAO,CAAA,CACT,CAMA,kBAAkB,CAAe,CAAE,CACjC,OAAO,OAAO,CAAC,GAAiB,OAAO,CAAC,AAAC,IACvC,IAAM,EAAM,CAAK,CAAC,EAAE,CACd,EAAQ,CAAK,CAAC,EAAE,AAEtB,CAAA,IAAI,CAAC,WAAW,CAAC,EAAI,CAAG,CAC1B,EACF,CAMA,mBAAmB,CAAK,CAAE,CACxB,OAAO,MAAM,IAAI,CAAC,EAAM,GAAG,CAAC,AAAC,GAAS,MAAM,IAAI,CAAC,GAAM,OAAO,IAChE,CAUA,2BAA2B,CAAK,CAAE,CAAS,CAAE,CAC3C,OAAQ,GACN,KAAK,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,IAAI,CAC3B,OAAO,CAGT,MAAK,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,KAAK,CAC5B,OAAO,IAAI,CAAC,kBAAkB,CAAC,EAGjC,MAAK,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,EAAE,CACzB,OAAO,IAAI,CAAC,cAAc,CAAC,EAAO,CAAA,EAGpC,MAAK,AAAA,EAAA,OAAQ,CAAE,SAAS,CAAC,IAAI,CAC3B,OAAO,IAAI,CAAC,cAAc,CAAC,EAAO,CAAA,EAEtC,CACF,CASA,eAAe,CAAK,CAAE,EAAU,CAAA,CAAK,CAAE,CACrC,IAAM,EAAiB,MAAM,IAAI,CAAC,GAAO,GAAG,CAAC,AAAC,GAAS,MAAM,IAAI,CAAC,IAQlE,OANA,EAAM,OAAO,CAAC,CAAC,EAAM,KACnB,EAAK,OAAO,CAAC,CAAC,EAAM,KAClB,CAAc,CAAC,EAAE,CAAC,EAAE,CAAG,CACzB,EACF,GAEO,EACH,EAAe,OAAO,GAAG,GAAG,CAAC,AAAC,GAAS,EAAK,OAAO,IACnD,CACN,CAOA,aAAa,CAAK,CAAE,CAClB,OAAO,MAAM,IAAI,CAAC,GAAO,GAAG,CAAC,AAAC,GACrB,MAAM,IAAI,CAAC,GAAM,MAAM,CAAC,AAAC,GAAQ,AAAQ,IAAR,GAE5C,CAOA,eAAe,CAAK,CAAE,CACpB,OAAO,MAAM,IAAI,CAAC,GAAO,GAAG,CAAC,AAAC,IAC5B,IAAI,CAAA,EAAK,MAAM,CAAG,AAAA,EAAA,OAAQ,CAAE,UAAU,AAAV,EAO1B,OAAO,MAAM,IAAI,CAAC,EAPoB,EACtC,IAAM,EAAc,MAAM,IAAI,CAAC,GAI/B,OAFA,EAAY,MAAM,CAAG,AAAA,EAAA,OAAQ,CAAE,UAAU,CAElC,EAAY,IAAI,CAAC,EAAG,EAAK,MAAM,CAAE,AAAA,EAAA,OAAQ,CAAE,UAAU,CAC9D,CAGF,EACF,CAWA,kBAAkB,CAAK,CAAE,CACvB,IAAM,EAAc,MAAM,IAAI,CAAC,GAC3B,EAAQ,EAEZ,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAChC,IAAK,IAAI,EAAI,EAAG,EAAI,CAAK,CAAC,EAAE,CAAC,MAAM,CAAG,EAAG,IAAK,CAC5C,IAAM,EAAU,CAAK,CAAC,EAAE,CAAC,EAAE,CACrB,EAAO,CAAK,CAAC,EAAE,CAAC,EAAI,EAAE,CAE5B,GAAI,AAAY,IAAZ,GAIA,IAAY,EAAM,CACpB,IAAM,EAAa,AAAU,EAAV,EAEf,IAAe,AAAA,EAAA,OAAQ,CAAE,SAAS,EACpC,IAAI,CAAC,iBAAiB,CAAC,CAAE,OAAQ,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,GAAG,AAAC,GAGxD,GAAS,EACT,CAAW,CAAC,EAAE,CAAC,EAAE,CAAG,EACpB,CAAW,CAAC,EAAE,CAAC,EAAI,EAAE,CAAG,CAC1B,CACF,CAKF,MAAO,CAAE,MAAO,EAAO,qBAFS,IAAI,CAAC,YAAY,CAAC,EAEmB,CACvE,CAQA,mBAAmB,CAAS,CAAE,CAQ5B,MAAO,AAPW,CAAA,CAChB,KAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAC7B,MAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAC/B,GAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EACzB,KAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAC/B,CAAA,CAEgB,CAAC,EAAU,AAC7B,CAOA,KAAK,CAAS,CAAE,CAEd,IAAM,EAAmB,IAAI,CAAC,0BAA0B,CACtD,IAAI,CAAC,QAAQ,GACb,GAQF,GAJA,IAAI,CAAC,iBAAiB,CAAC,CACrB,aAAc,IAAI,CAAC,+BAA+B,CAAC,EACrD,GAEI,CAAC,IAAI,CAAC,cAAc,GAAG,YAAY,CACrC,MAAO,CAAA,EAIT,IAAM,EAAqB,IAAI,CAAC,YAAY,CAAC,GAGvC,CAAA,MAAE,CAAK,CAAA,qBAAE,CAAoB,CAAE,CACnC,IAAI,CAAC,iBAAiB,CAAC,GAGnB,EAAyB,IAAI,CAAC,cAAc,CAAC,GAG7C,EAAqB,IAAI,CAAC,0BAA0B,CACxD,EACA,GAUF,OANA,IAAI,CAAC,iBAAiB,CAAC,CACrB,MAAO,IAAI,CAAC,QAAQ,GAAK,EACzB,MAAO,EACP,MAAQ,IAAI,CAAC,cAAc,GAAG,KAAK,EAAI,CACzC,GAEO,CAAA,CACT,CAOA,mBAAoB,CAClB,OAAO,KAAK,MAAM,GAAK,AAAA,EAAA,OAAQ,CAAE,oBAAoB,AACvD,CAQA,oCAAoC,CAAM,CAAE,CAAW,CAAE,CACvD,IAAM,EAAS,KAAK,MAAM,GAE1B,OAAO,EAAS,EAAc,EAAS,CACzC,CASA,oBAAqB,CACnB,IAAM,EAAQ,IAAI,CAAC,QAAQ,GACrB,EAAe,MAAM,IAAI,CAAC,GAAO,GAAG,CAAC,AAAC,GAAS,MAAM,IAAI,CAAC,IAE5D,EAAQ,EACN,EAAc,IAAM,EAAI,EAC1B,EAAM,GACN,EAAM,GACN,EAAkB,GAEtB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAChC,IAAK,IAAI,EAAI,EAAG,EAAI,CAAK,CAAC,EAAE,CAAC,MAAM,CAAE,IAAK,CACxC,GAAI,AAAgB,IAAhB,CAAK,CAAC,EAAE,CAAC,EAAE,CACb,SAGF,IAAM,EAAS,IAAI,CAAC,mCAAmC,CACrD,EACA,KAGE,IAAW,IACb,EAAkB,EAClB,EAAM,EACN,EAAM,GAGR,GACF,CAGF,GAAI,AAAQ,KAAR,GAAc,AAAQ,KAAR,GAAc,AAA2B,KAAA,IAA3B,CAAY,CAAC,EAAI,CAAC,EAAI,CACpD,MAAO,CAAE,YAAa,CAAA,CAAK,EAG7B,IAAM,EAAQ,IAAI,CAAC,iBAAiB,GAAK,EAAI,SAE7C,AAAI,AAA2B,IAA3B,CAAY,CAAC,EAAI,CAAC,EAAI,EACxB,CAAY,CAAC,EAAI,CAAC,EAAI,CAAG,EACzB,IAAI,CAAC,iBAAiB,CAAC,CAAE,MAAO,CAAa,GAEtC,CACL,YAAa,CAAA,EACb,IAAK,EACL,IAAK,EACL,MAAO,CACT,GAGK,CAAE,YAAa,CAAA,CAAK,CAC7B,CACF,EDreM,EAAY,SAAS,aAAa,CAAC,eACnC,EAAa,SAAS,aAAa,CAAC,eAEpC,EAAqB,AAAC,IAG1B,IAAK,IAAM,KAFO,EAAK,SAAS,CAGjB,eAAT,GACF,EAAK,SAAS,CAAC,MAAM,CAAC,EAG5B,EAEM,EAAc,KAClB,IAAM,EAAQ,EAAK,QAAQ,GAErB,EAAO,EAAU,IAAI,CAE3B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAAK,CACrC,IAAM,EAAW,CAAI,CAAC,EAAE,CAAC,KAAK,CACxB,EAAW,CAAK,CAAC,EAAE,CAEzB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAAK,CACxC,IAAM,EAAW,CAAQ,CAAC,EAAE,CACtB,EAAO,CAAQ,CAAC,EAAE,CAExB,EAAmB,GAEf,AAAa,IAAb,GACF,EAAK,SAAS,CAAG,EACjB,EAAK,SAAS,CAAC,GAAG,CAAC,eAAiB,IAEpC,EAAK,SAAS,CAAG,EAErB,CACF,CACA,EAAW,SAAS,CAAG,EAAK,QAAQ,EACtC,EAEM,EAAa,AAAC,IAClB,GAAM,CAAA,YAAE,CAAW,CAAA,IAAE,CAAG,CAAA,IAAE,CAAG,CAAA,MAAE,CAAK,CAAE,CAAG,EAEzC,GAAI,EACF,OAGF,IAAM,EAAO,EAAU,IAAI,CAAC,EAAI,CAAC,KAAK,CAAC,EAAI,CAEvC,IACF,EAAK,SAAS,CAAG,EACjB,EAAK,SAAS,CAAC,GAAG,CAAC,eAAiB,GAExC,EAEM,EAAc,SAAS,aAAa,CAAC,UACrC,EAAgB,SAAS,aAAa,CAAC,YAEvC,EAA8B,KAElC,AAAA,CAAA,EAAA,EAAA,OAAyB,AAAzB,EAA2B,aAAa,CAAC,YAEzC,AAAA,CAAA,EAAA,EAAA,OAAyB,AAAzB,EAA2B,kBAAkB,CAAC,mBAChD,EAEM,EAAqB,AAAC,IACtB,IAAe,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,GAAG,EACrC,AAAA,CAAA,EAAA,EAAA,OAAyB,AAAzB,EAA2B,kBAAkB,CAAC,gBAG5C,IAAe,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,IAAI,EACtC,AAAA,CAAA,EAAA,EAAA,OAAyB,AAAzB,EAA2B,kBAAkB,CAAC,iBAG5C,IAAe,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,OAAO,EACzC,AAAA,CAAA,EAAA,EAAA,OAAyB,AAAzB,EAA2B,YAAY,GAEzC,GACF,EAEM,EAAkB,AAAC,IAErB,EAAK,SAAS,KAAO,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,GAAG,EACzC,EAAK,SAAS,KAAO,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,IAAI,EAoB5C,AAfgB,IAAI,QAAQ,CAAC,EAAS,KAChC,EAAK,WAAW,IAClB,EAAO,AAAI,MAAM,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,IAAI,GAIlB,AADD,EAAK,kBAAkB,CAAC,KAI3C,EAAQ,SAER,EAAO,AAAI,MAAM,eAErB,GAGG,IAAI,CAAC,AAAC,IAUL,GARA,QAAQ,GAAG,CAAC,GAEZ,IAEwB,IAApB,EAAK,QAAQ,IACf,IAGE,EAAK,SAAS,KAAO,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,GAAG,CAAE,CAC7C,EAAmB,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,GAAG,EAEvC,MACF,CAEA,WAAW,IAAM,EAAW,EAAK,kBAAkB,IAAK,IAC1D,GACC,KAAK,CAAC,AAAC,IAEN,QAAQ,GAAG,CAAC,CAAE,IAAA,CAAI,GAEd,EAAI,OAAO,GAAK,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,IAAI,EACvC,EAAmB,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,IAAI,EAGtB,gBAAhB,EAAI,OAAO,EAEb,QAAQ,GAAG,CAAC,EAAI,OAAO,CAE3B,EACJ,EAEM,EAAqB,AAAC,IAC1B,IAAM,EAAY,EAAE,GAAG,CAEnB,GAAa,AAAA,CAAA,EAAA,EAAA,aAAY,AAAZ,EAAc,SAAS,CAAC,cAAc,CAAC,IAGtD,EAFkB,AAAA,CAAA,EAAA,EAAA,aAAY,AAAZ,EAAc,yBAAyB,CAAC,GAI9D,EAEM,EAAmB,AAAC,IAGxB,EAFkB,AAAA,CAAA,EAAA,EAAA,eAAc,AAAd,EAAgB,cAAc,CAAC,GAGnD,EAuBM,EAAwB,KAC5B,SAAS,gBAAgB,CAAC,UAAW,GAErC,EAAU,gBAAgB,CACxB,aACA,AAAA,CAAA,EAAA,EAAA,eAAc,AAAd,EAAgB,gBAAgB,CAAC,IAAI,CAAC,EAAA,eAAc,GAEtD,EAAU,gBAAgB,CAAC,WAAY,GAEvC,EAAU,gBAAgB,CACxB,YACA,AAAA,CAAA,EAAA,EAAA,eAAc,AAAd,EAAgB,oBAAoB,CAAC,IAAI,CAAC,EAAA,eAAc,EAE5D,EAEM,EAA2B,KAC/B,SAAS,mBAAmB,CAAC,UAAW,GAExC,EAAU,mBAAmB,CAC3B,aACA,AAAA,CAAA,EAAA,EAAA,eAAc,AAAd,EAAgB,gBAAgB,CAAC,IAAI,CAAC,EAAA,eAAc,GAEtD,EAAU,mBAAmB,CAAC,WAAY,GAE1C,EAAU,mBAAmB,CAC3B,YACA,AAAA,CAAA,EAAA,EAAA,eAAc,AAAd,EAAgB,oBAAoB,CAAC,IAAI,CAAC,EAAA,eAAc,EAE5D,EAEA,EAAY,gBAAgB,CAAC,QAnDJ,KACnB,EAAK,SAAS,KAAO,AAAA,EAAA,OAAQ,CAAE,MAAM,CAAC,OAAO,GAIjD,IAEA,EAAK,KAAK,GACV,AAAA,CAAA,EAAA,EAAA,OAAyB,AAAzB,EAA2B,UAAU,GACrC,IACF,GA2CA,EAAc,gBAAgB,CAAC,QAzCJ,KACzB,IACA,IACA,AAAA,CAAA,EAAA,EAAA,OAAyB,AAAzB,EAA2B,kBAAkB,CAAC,oBAC9C,EAAK,OAAO,GACZ,IACA,AAAA,CAAA,EAAA,EAAA,OAAyB,AAAzB,EAA2B,UAAU,EACvC","sources":["<anon>","src/scripts/main.js","src/modules/Game.class.js"],"sourcesContent":["\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire7b01\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire7b01\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $ahdtQ = parcelRequire(\"ahdtQ\");\n\nvar $8zzUU = parcelRequire(\"8zzUU\");\n\nvar $8HyT0 = parcelRequire(\"8HyT0\");\n\"use strict\";\nvar $a5fd07fa01589658$exports = {};\n\nvar $ahdtQ = parcelRequire(\"ahdtQ\");\n\"use strict\";\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */ class $a5fd07fa01589658$var$Game {\n    /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */ constructor(initialState = (0, $ahdtQ.default).INITIAL_STATE){\n        this.gameContext = {\n            state: initialState,\n            score: 0,\n            status: (0, $ahdtQ.default).STATUS.idle,\n            movePossible: true,\n            moves: 0\n        };\n    }\n    moveLeft() {\n        return this.move((0, $ahdtQ.default).DIRECTION.left);\n    }\n    moveRight() {\n        return this.move((0, $ahdtQ.default).DIRECTION.right);\n    }\n    moveUp() {\n        return this.move((0, $ahdtQ.default).DIRECTION.up);\n    }\n    moveDown() {\n        return this.move((0, $ahdtQ.default).DIRECTION.down);\n    }\n    /**\n   * @returns {number}\n   */ getScore() {\n        return this.gameContext.score;\n    }\n    /**\n   * @returns {number[][]}\n   */ getState() {\n        return Array.from(this.gameContext.state).map((line)=>Array.from(line));\n    }\n    /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */ getStatus() {\n        return this.getGameContext().status;\n    }\n    /**\n   * Starts the game.\n   */ start() {\n        this.updateGameContext({\n            status: (0, $ahdtQ.default).STATUS.playing\n        });\n        this.addRandomCellValue();\n        this.addRandomCellValue();\n    }\n    /**\n   * Resets the game.\n   */ restart() {\n        this.updateGameContext({\n            score: 0,\n            state: (0, $ahdtQ.default).INITIAL_STATE,\n            status: (0, $ahdtQ.default).STATUS.playing\n        });\n        this.addRandomCellValue();\n        this.addRandomCellValue();\n    }\n    // Add your own methods here\n    /**\n   * Updates context with 'win' status\n   */ win() {\n        this.updateGameContext({\n            status: (0, $ahdtQ.default).STATUS.win\n        });\n    }\n    /**\n   * Updates context with 'lose' status\n   */ lose() {\n        this.updateGameContext({\n            status: (0, $ahdtQ.default).STATUS.lose\n        });\n    }\n    /**\n   * returns number of moves made since start/restart of the game\n   * @returns {number}\n   */ getMoves() {\n        return this.getGameContext().moves;\n    }\n    /**\n   * returns game context contatining core stats of the game\n   * @returns {object}\n   */ getGameContext() {\n        return this.gameContext;\n    }\n    /**\n   * function checks whether any particular tile can be moved in a position of\n   * the next tile in the direction of the move (or merged with it)\n   * @param {number} first\n   * @param {number} second\n   * @returns {boolean} true (if move or merge is possible), otherwise - false\n   */ canMoveOrMergeCells(first, second) {\n        return first === 0 && second !== 0 || (first !== 0 || second !== 0) && first === second;\n    }\n    /**\n   * checks whether current state of the field has tiles with zero value.\n   * @returns {boolean}\n   */ stateHasZeroes() {\n        return this.getState().some((line)=>{\n            return line.some((cell)=>cell === 0);\n        });\n    }\n    /**\n   * checks whether current state of the field has at least\n   * one case of tiles that can be merged\n   * @returns {boolean}\n   */ mergeIsPossible() {\n        const state = this.getState();\n        for(let i = 0; i < state.length; i++)for(let j = 0; j < state[i].length; j++){\n            const current = state[i][j];\n            const right = state[i][j + 1];\n            if (right && current === right) return true;\n            if (i === state.length - 1) continue;\n            const below = state[i + 1][j];\n            if (below && current === below) return true;\n        }\n        return false;\n    }\n    /**\n   * Checks if the current state of the field has any moves available.\n   * @returns {boolean}\n   */ checkIfLost() {\n        return !this.stateHasZeroes() && !this.mergeIsPossible();\n    }\n    /**\n   * Checks whether any cell line (1d array) has any moves available.\n   * @param {number[][]} state\n   * @returns {boolean}\n   */ checkAvailableMovesOnSingleLine(state) {\n        for(let i = 0; i < state.length; i++)for(let j = 0; j < state[i].length - 1; j++){\n            const first = state[i][j];\n            const second = state[i][j + 1];\n            if (this.canMoveOrMergeCells(first, second)) return true;\n        }\n        return false;\n    }\n    /**\n   * Method updates current state of the game context with new values\n   * @param {object} keyValuePairObj\n   */ updateGameContext(keyValuePairObj) {\n        Object.entries(keyValuePairObj).forEach((entry)=>{\n            const key = entry[0];\n            const value = entry[1];\n            this.gameContext[key] = value;\n        });\n    }\n    /**\n   * @param {number[][]} state - some form of state of the field\n   * @returns {number[][]} copy of the state reversed horizontally\n   */ reverseStateByAxis(state) {\n        return Array.from(state.map((line)=>Array.from(line).reverse()));\n    }\n    /**\n   * Function calls relevant functions which may need to\n   * transpose and/or reverses state of the field\n   * depending on direction of the move\n   * @param {number[][]} state - some form of state of the field\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {number[][]} copy of updated state of the field\n   */ transformStatePerDirection(state, direction) {\n        switch(direction){\n            case (0, $ahdtQ.default).DIRECTION.left:\n                return state;\n            case (0, $ahdtQ.default).DIRECTION.right:\n                return this.reverseStateByAxis(state);\n            case (0, $ahdtQ.default).DIRECTION.up:\n                return this.transposeState(state, false);\n            case (0, $ahdtQ.default).DIRECTION.down:\n                return this.transposeState(state, true);\n        }\n    }\n    /**\n   * Function transposes rows of the state of the field into columns.\n   * If needed, function reverses the lines of the transposed field.\n   * @param {number[][]} state - some form of state of the field\n   * @param {boolean} reverse - whether the transposed field should be reversed.\n   * @returns copy of the transposed/reversed state of the field.\n   */ transposeState(state, reverse = false) {\n        const transposeState = Array.from(state).map((line)=>Array.from(line));\n        state.forEach((line, i)=>{\n            line.forEach((cell, j)=>{\n                transposeState[j][i] = cell;\n            });\n        });\n        return reverse ? transposeState.reverse().map((line)=>line.reverse()) : transposeState;\n    }\n    /**\n   * Function removes zeroes from the state of the field.\n   * @param {number[][]} state - some form of the state of the field\n   * @returns {number[][]} - copy of the the field without zero valued tiles\n   */ removeZeroes(state) {\n        return Array.from(state).map((line)=>{\n            return Array.from(line).filter((num)=>num !== 0);\n        });\n    }\n    /**\n   * Functions adds zeroes to empty tiles (after moves and merges are complete)\n   * @param {number[][]} state - some form of the state of the field\n   * @returns {number[][]} - copy of the field filled with 0 valued cells\n   */ fillWithZeroes(state) {\n        return Array.from(state).map((line)=>{\n            if (line.length < (0, $ahdtQ.default).FIELD_SIZE) {\n                const updatedLine = Array.from(line);\n                updatedLine.length = (0, $ahdtQ.default).FIELD_SIZE;\n                return updatedLine.fill(0, line.length, (0, $ahdtQ.default).FIELD_SIZE);\n            } else return Array.from(line);\n        });\n    }\n    /**\n   * Function that processes:\n   * (1) move of non-zero tiles\n   * (2) merge of tiles\n   * (3) update score per turn\n   * (4) removes zeroes got as a result of merge\n   * @param {number[][]} state - some form of the field\n   * @returns {number[][]} - copy of the field with moved/merged cells\n   */ moveAndMergeTiles(state) {\n        const resultField = Array.from(state);\n        let score = 0;\n        for(let i = 0; i < state.length; i++)for(let j = 0; j < state[i].length - 1; j++){\n            const current = state[i][j];\n            const next = state[i][j + 1];\n            if (current === 0) continue;\n            if (current === next) {\n                const mergeValue = current * 2;\n                if (mergeValue === (0, $ahdtQ.default).WIN_VALUE) this.updateGameContext({\n                    status: (0, $ahdtQ.default).STATUS.win\n                });\n                score += mergeValue;\n                resultField[i][j] = mergeValue;\n                resultField[i][j + 1] = 0;\n            }\n        }\n        const resultWithNoExtraZeroes = this.removeZeroes(resultField);\n        return {\n            score: score,\n            stateWithMergedTiles: resultWithNoExtraZeroes\n        };\n    }\n    /**\n   * Function that selects proper move function\n   * depending on the direction of the move\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {function}\n   */ selectMoveFunction(direction) {\n        const functions = {\n            left: this.moveLeft.bind(this),\n            right: this.moveRight.bind(this),\n            up: this.moveUp.bind(this),\n            down: this.moveDown.bind(this)\n        };\n        return functions[direction];\n    }\n    /**\n   * Function that coordinates the procedure of the move\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {boolean} true, if move succesfully processed\n   */ move(direction) {\n        // transform state (per X and Y axis) into convenient rows\n        const transformedState = this.transformStatePerDirection(this.getState(), direction);\n        // if move is not possible, move is not processed\n        this.updateGameContext({\n            movePossible: this.checkAvailableMovesOnSingleLine(transformedState)\n        });\n        if (!this.getGameContext().movePossible) return false;\n        // if move possible, remove zero tiles\n        const stateWithoutZeroes = this.removeZeroes(transformedState);\n        // merge tiles and calculate score\n        const { score: score, stateWithMergedTiles: stateWithMergedTiles } = this.moveAndMergeTiles(stateWithoutZeroes);\n        // empty tiles assigned with zero values\n        const updatedStateWithZeroes = this.fillWithZeroes(stateWithMergedTiles);\n        // re-transform X and Y axes back to their original state\n        const reTransformedState = this.transformStatePerDirection(updatedStateWithZeroes, direction);\n        // update game context with results of the move\n        this.updateGameContext({\n            score: this.getScore() + score,\n            state: reTransformedState,\n            moves: this.getGameContext().moves += 1\n        });\n        return true;\n    }\n    /**\n   * Function checks whether 4 valued cell should be added\n   * with certain probability (currently 10%)\n   * @returns {boolean}\n   */ isTimeForFourTile() {\n        return Math.random() < (0, $ahdtQ.default).PROBABILITY_FOR_FOUR;\n    }\n    /**\n   *\n   * @param {number} number\n   * @param {number} probability - number between 0 and 1\n   * @returns\n   */ randomlyChangeNumberWithProbability(number, probability) {\n        const random = Math.random();\n        return random < probability ? random : number;\n    }\n    /**\n   * Function analyses current state of the field and randomly adds\n   * a new cell with value of 2 (90% probability) or 4 (10% probability).\n   * Function is based on Reservoir Sampling algorithm.\n   * @returns {object} contains boolean field 'failedToAdd' and,\n   * in case of success, also contains row and col numbers and respective value.\n   */ addRandomCellValue() {\n        const state = this.getState();\n        const updatedField = Array.from(state).map((line)=>Array.from(line));\n        let count = 1;\n        const probability = ()=>1 / count;\n        let row = -1;\n        let col = -1;\n        let referenceRandom = -1;\n        for(let i = 0; i < state.length; i++)for(let j = 0; j < state[i].length; j++){\n            if (state[i][j] !== 0) continue;\n            const random = this.randomlyChangeNumberWithProbability(referenceRandom, probability());\n            if (random !== referenceRandom) {\n                referenceRandom = random;\n                row = i;\n                col = j;\n            }\n            count++;\n        }\n        if (row === -1 || col === -1 || updatedField[row][col] === undefined) return {\n            failedToAdd: true\n        };\n        const value = this.isTimeForFourTile() ? 4 : 2;\n        if (updatedField[row][col] === 0) {\n            updatedField[row][col] = value;\n            this.updateGameContext({\n                state: updatedField\n            });\n            return {\n                failedToAdd: false,\n                row: row,\n                col: col,\n                value: value\n            };\n        }\n        return {\n            failedToAdd: true\n        };\n    }\n}\n$a5fd07fa01589658$exports = $a5fd07fa01589658$var$Game;\n\n\nconst $09e991522ca7e64e$var$game = new $a5fd07fa01589658$exports();\n// Write your code here\nconst $09e991522ca7e64e$var$gameField = document.querySelector(\".game-field\");\nconst $09e991522ca7e64e$var$scoreField = document.querySelector(\".game-score\");\nconst $09e991522ca7e64e$var$resetCellClassName = (cell)=>{\n    const classList = cell.classList;\n    for (const item of classList)if (item !== \"field-cell\") cell.classList.remove(item);\n};\nconst $09e991522ca7e64e$var$renderBoard = ()=>{\n    const state = $09e991522ca7e64e$var$game.getState();\n    const rows = $09e991522ca7e64e$var$gameField.rows;\n    for(let i = 0; i < state.length; i++){\n        const fieldRow = rows[i].cells;\n        const stateRow = state[i];\n        for(let j = 0; j < fieldRow.length; j++){\n            const newValue = stateRow[j];\n            const cell = fieldRow[j];\n            $09e991522ca7e64e$var$resetCellClassName(cell);\n            if (newValue !== 0) {\n                cell.innerHTML = newValue;\n                cell.classList.add(\"field-cell--\" + newValue);\n            } else cell.innerHTML = \"\";\n        }\n    }\n    $09e991522ca7e64e$var$scoreField.innerHTML = $09e991522ca7e64e$var$game.getScore();\n};\nconst $09e991522ca7e64e$var$renderCell = (AddNewCellResult)=>{\n    const { failedToAdd: failedToAdd, row: row, col: col, value: value } = AddNewCellResult;\n    if (failedToAdd) return;\n    const cell = $09e991522ca7e64e$var$gameField.rows[row].cells[col];\n    if (cell) {\n        cell.innerHTML = value;\n        cell.classList.add(\"field-cell--\" + value);\n    }\n};\nconst $09e991522ca7e64e$var$startButton = document.querySelector(\".start\");\nconst $09e991522ca7e64e$var$restartButton = document.querySelector(\".restart\");\nconst $09e991522ca7e64e$var$modificationsAfterFirstMove = ()=>{\n    // change buttons to restart\n    (0, $8HyT0.default).switchButtons(\".restart\");\n    // change message to restart\n    (0, $8HyT0.default).makeMessageVisible(\".message-restart\");\n};\nconst $09e991522ca7e64e$var$handleEndGameEvent = (gameStatus)=>{\n    if (gameStatus === (0, $ahdtQ.default).STATUS.win) (0, $8HyT0.default).makeMessageVisible(\".message-win\");\n    if (gameStatus === (0, $ahdtQ.default).STATUS.lose) (0, $8HyT0.default).makeMessageVisible(\".message-lose\");\n    if (gameStatus !== (0, $ahdtQ.default).STATUS.playing) (0, $8HyT0.default).defocusField();\n    $09e991522ca7e64e$var$removeMoveEventListeners();\n};\nconst $09e991522ca7e64e$var$handleMoveEvent = (direction)=>{\n    if ($09e991522ca7e64e$var$game.getStatus() === (0, $ahdtQ.default).STATUS.win || $09e991522ca7e64e$var$game.getStatus() === (0, $ahdtQ.default).STATUS.lose) return;\n    const promise = new Promise((resolve, reject)=>{\n        if ($09e991522ca7e64e$var$game.checkIfLost()) reject(new Error((0, $ahdtQ.default).STATUS.lose));\n        const moveFunction = $09e991522ca7e64e$var$game.selectMoveFunction(direction);\n        const moveProcessed = moveFunction();\n        if (moveProcessed) resolve(\"Moved\");\n        else reject(new Error(\"Move failed\"));\n    });\n    promise.then((message)=>{\n        // eslint-disable-next-line no-console\n        console.log(message);\n        $09e991522ca7e64e$var$renderBoard();\n        if ($09e991522ca7e64e$var$game.getMoves() === 1) $09e991522ca7e64e$var$modificationsAfterFirstMove();\n        if ($09e991522ca7e64e$var$game.getStatus() === (0, $ahdtQ.default).STATUS.win) {\n            $09e991522ca7e64e$var$handleEndGameEvent((0, $ahdtQ.default).STATUS.win);\n            return;\n        }\n        setTimeout(()=>$09e991522ca7e64e$var$renderCell($09e991522ca7e64e$var$game.addRandomCellValue()), 300);\n    }).catch((err)=>{\n        // eslint-disable-next-line no-console\n        console.log({\n            err: err\n        });\n        if (err.message === (0, $ahdtQ.default).STATUS.lose) $09e991522ca7e64e$var$handleEndGameEvent((0, $ahdtQ.default).STATUS.lose);\n        if (err.message === \"Move failed\") // eslint-disable-next-line no-console\n        console.log(err.message);\n    });\n};\nconst $09e991522ca7e64e$var$handleKeyDownEvent = (e)=>{\n    const targetKey = e.key;\n    if (targetKey && (0, $8zzUU.keyController).arrowKeys.hasOwnProperty(targetKey)) {\n        const direction = (0, $8zzUU.keyController).identifyArrowKeyDirection(targetKey);\n        $09e991522ca7e64e$var$handleMoveEvent(direction);\n    }\n};\nconst $09e991522ca7e64e$var$handleSwipeEvent = (e)=>{\n    const direction = (0, $8zzUU.swipeController).handleTouchEnd(e);\n    $09e991522ca7e64e$var$handleMoveEvent(direction);\n};\nconst $09e991522ca7e64e$var$handleStartEvent = ()=>{\n    if ($09e991522ca7e64e$var$game.getStatus() === (0, $ahdtQ.default).STATUS.playing) return;\n    $09e991522ca7e64e$var$addMoveEventListeners();\n    $09e991522ca7e64e$var$game.start();\n    (0, $8HyT0.default).focusField();\n    $09e991522ca7e64e$var$renderBoard();\n};\nconst $09e991522ca7e64e$var$handleRestartEvent = ()=>{\n    $09e991522ca7e64e$var$removeMoveEventListeners();\n    $09e991522ca7e64e$var$addMoveEventListeners();\n    (0, $8HyT0.default).makeMessageVisible(\".message-restart\");\n    $09e991522ca7e64e$var$game.restart();\n    $09e991522ca7e64e$var$renderBoard();\n    (0, $8HyT0.default).focusField();\n};\nconst $09e991522ca7e64e$var$addMoveEventListeners = ()=>{\n    document.addEventListener(\"keydown\", $09e991522ca7e64e$var$handleKeyDownEvent);\n    $09e991522ca7e64e$var$gameField.addEventListener(\"touchstart\", (0, $8zzUU.swipeController).handleTouchStart.bind((0, $8zzUU.swipeController)));\n    $09e991522ca7e64e$var$gameField.addEventListener(\"touchend\", $09e991522ca7e64e$var$handleSwipeEvent);\n    $09e991522ca7e64e$var$gameField.addEventListener(\"touchmove\", (0, $8zzUU.swipeController).preventScrollOnSwipe.bind((0, $8zzUU.swipeController)));\n};\nconst $09e991522ca7e64e$var$removeMoveEventListeners = ()=>{\n    document.removeEventListener(\"keydown\", $09e991522ca7e64e$var$handleKeyDownEvent);\n    $09e991522ca7e64e$var$gameField.removeEventListener(\"touchstart\", (0, $8zzUU.swipeController).handleTouchStart.bind((0, $8zzUU.swipeController)));\n    $09e991522ca7e64e$var$gameField.removeEventListener(\"touchend\", $09e991522ca7e64e$var$handleSwipeEvent);\n    $09e991522ca7e64e$var$gameField.removeEventListener(\"touchmove\", (0, $8zzUU.swipeController).preventScrollOnSwipe.bind((0, $8zzUU.swipeController)));\n};\n$09e991522ca7e64e$var$startButton.addEventListener(\"click\", $09e991522ca7e64e$var$handleStartEvent);\n$09e991522ca7e64e$var$restartButton.addEventListener(\"click\", $09e991522ca7e64e$var$handleRestartEvent);\n\n\n//# sourceMappingURL=index.3eb5e11a.js.map\n","'use strict';\n\nimport constants from './constants.js';\nimport { keyController, swipeController } from './keySwipeController.js';\nimport statusVisibilityController from './statusVisibilityController.js';\n\n// Uncomment the next lines to use your game instance in the browser\nconst Game = require('../modules/Game.class');\nconst game = new Game();\n\n// Write your code here\nconst gameField = document.querySelector('.game-field');\nconst scoreField = document.querySelector('.game-score');\n\nconst resetCellClassName = (cell) => {\n  const classList = cell.classList;\n\n  for (const item of classList) {\n    if (item !== 'field-cell') {\n      cell.classList.remove(item);\n    }\n  }\n};\n\nconst renderBoard = () => {\n  const state = game.getState();\n\n  const rows = gameField.rows;\n\n  for (let i = 0; i < state.length; i++) {\n    const fieldRow = rows[i].cells;\n    const stateRow = state[i];\n\n    for (let j = 0; j < fieldRow.length; j++) {\n      const newValue = stateRow[j];\n      const cell = fieldRow[j];\n\n      resetCellClassName(cell);\n\n      if (newValue !== 0) {\n        cell.innerHTML = newValue;\n        cell.classList.add('field-cell--' + newValue);\n      } else {\n        cell.innerHTML = '';\n      }\n    }\n  }\n  scoreField.innerHTML = game.getScore();\n};\n\nconst renderCell = (AddNewCellResult) => {\n  const { failedToAdd, row, col, value } = AddNewCellResult;\n\n  if (failedToAdd) {\n    return;\n  }\n\n  const cell = gameField.rows[row].cells[col];\n\n  if (cell) {\n    cell.innerHTML = value;\n    cell.classList.add('field-cell--' + value);\n  }\n};\n\nconst startButton = document.querySelector('.start');\nconst restartButton = document.querySelector('.restart');\n\nconst modificationsAfterFirstMove = () => {\n  // change buttons to restart\n  statusVisibilityController.switchButtons('.restart');\n  // change message to restart\n  statusVisibilityController.makeMessageVisible('.message-restart');\n};\n\nconst handleEndGameEvent = (gameStatus) => {\n  if (gameStatus === constants.STATUS.win) {\n    statusVisibilityController.makeMessageVisible('.message-win');\n  }\n\n  if (gameStatus === constants.STATUS.lose) {\n    statusVisibilityController.makeMessageVisible('.message-lose');\n  }\n\n  if (gameStatus !== constants.STATUS.playing) {\n    statusVisibilityController.defocusField();\n  }\n  removeMoveEventListeners();\n};\n\nconst handleMoveEvent = (direction) => {\n  if (\n    game.getStatus() === constants.STATUS.win ||\n    game.getStatus() === constants.STATUS.lose\n  ) {\n    return;\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    if (game.checkIfLost()) {\n      reject(new Error(constants.STATUS.lose));\n    }\n\n    const moveFunction = game.selectMoveFunction(direction);\n    const moveProcessed = moveFunction();\n\n    if (moveProcessed) {\n      resolve('Moved');\n    } else {\n      reject(new Error('Move failed'));\n    }\n  });\n\n  promise\n    .then((message) => {\n      // eslint-disable-next-line no-console\n      console.log(message);\n\n      renderBoard();\n\n      if (game.getMoves() === 1) {\n        modificationsAfterFirstMove();\n      }\n\n      if (game.getStatus() === constants.STATUS.win) {\n        handleEndGameEvent(constants.STATUS.win);\n\n        return;\n      }\n\n      setTimeout(() => renderCell(game.addRandomCellValue()), 300);\n    })\n    .catch((err) => {\n      // eslint-disable-next-line no-console\n      console.log({ err });\n\n      if (err.message === constants.STATUS.lose) {\n        handleEndGameEvent(constants.STATUS.lose);\n      }\n\n      if (err.message === 'Move failed') {\n        // eslint-disable-next-line no-console\n        console.log(err.message);\n      }\n    });\n};\n\nconst handleKeyDownEvent = (e) => {\n  const targetKey = e.key;\n\n  if (targetKey && keyController.arrowKeys.hasOwnProperty(targetKey)) {\n    const direction = keyController.identifyArrowKeyDirection(targetKey);\n\n    handleMoveEvent(direction);\n  }\n};\n\nconst handleSwipeEvent = (e) => {\n  const direction = swipeController.handleTouchEnd(e);\n\n  handleMoveEvent(direction);\n};\n\nconst handleStartEvent = () => {\n  if (game.getStatus() === constants.STATUS.playing) {\n    return;\n  }\n\n  addMoveEventListeners();\n\n  game.start();\n  statusVisibilityController.focusField();\n  renderBoard();\n};\n\nconst handleRestartEvent = () => {\n  removeMoveEventListeners();\n  addMoveEventListeners();\n  statusVisibilityController.makeMessageVisible('.message-restart');\n  game.restart();\n  renderBoard();\n  statusVisibilityController.focusField();\n};\n\nconst addMoveEventListeners = () => {\n  document.addEventListener('keydown', handleKeyDownEvent);\n\n  gameField.addEventListener(\n    'touchstart',\n    swipeController.handleTouchStart.bind(swipeController),\n  );\n  gameField.addEventListener('touchend', handleSwipeEvent);\n\n  gameField.addEventListener(\n    'touchmove',\n    swipeController.preventScrollOnSwipe.bind(swipeController),\n  );\n};\n\nconst removeMoveEventListeners = () => {\n  document.removeEventListener('keydown', handleKeyDownEvent);\n\n  gameField.removeEventListener(\n    'touchstart',\n    swipeController.handleTouchStart.bind(swipeController),\n  );\n  gameField.removeEventListener('touchend', handleSwipeEvent);\n\n  gameField.removeEventListener(\n    'touchmove',\n    swipeController.preventScrollOnSwipe.bind(swipeController),\n  );\n};\n\nstartButton.addEventListener('click', handleStartEvent);\n\nrestartButton.addEventListener('click', handleRestartEvent);\n","'use strict';\n\nimport constants from '../scripts/constants.js';\n\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */\nclass Game {\n  /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */\n  constructor(initialState = constants.INITIAL_STATE) {\n    this.gameContext = {\n      state: initialState,\n      score: 0,\n      status: constants.STATUS.idle,\n      movePossible: true,\n      moves: 0,\n    };\n  }\n\n  moveLeft() {\n    return this.move(constants.DIRECTION.left);\n  }\n  moveRight() {\n    return this.move(constants.DIRECTION.right);\n  }\n  moveUp() {\n    return this.move(constants.DIRECTION.up);\n  }\n  moveDown() {\n    return this.move(constants.DIRECTION.down);\n  }\n\n  /**\n   * @returns {number}\n   */\n  getScore() {\n    return this.gameContext.score;\n  }\n\n  /**\n   * @returns {number[][]}\n   */\n  getState() {\n    return Array.from(this.gameContext.state).map((line) => Array.from(line));\n  }\n\n  /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */\n  getStatus() {\n    return this.getGameContext().status;\n  }\n\n  /**\n   * Starts the game.\n   */\n  start() {\n    this.updateGameContext({ status: constants.STATUS.playing });\n    this.addRandomCellValue();\n    this.addRandomCellValue();\n  }\n\n  /**\n   * Resets the game.\n   */\n  restart() {\n    this.updateGameContext({\n      score: 0,\n      state: constants.INITIAL_STATE,\n      status: constants.STATUS.playing,\n    });\n    this.addRandomCellValue();\n    this.addRandomCellValue();\n  }\n\n  // Add your own methods here\n  /**\n   * Updates context with 'win' status\n   */\n  win() {\n    this.updateGameContext({ status: constants.STATUS.win });\n  }\n\n  /**\n   * Updates context with 'lose' status\n   */\n  lose() {\n    this.updateGameContext({ status: constants.STATUS.lose });\n  }\n\n  /**\n   * returns number of moves made since start/restart of the game\n   * @returns {number}\n   */\n  getMoves() {\n    return this.getGameContext().moves;\n  }\n\n  /**\n   * returns game context contatining core stats of the game\n   * @returns {object}\n   */\n  getGameContext() {\n    return this.gameContext;\n  }\n\n  /**\n   * function checks whether any particular tile can be moved in a position of\n   * the next tile in the direction of the move (or merged with it)\n   * @param {number} first\n   * @param {number} second\n   * @returns {boolean} true (if move or merge is possible), otherwise - false\n   */\n  canMoveOrMergeCells(first, second) {\n    return (\n      (first === 0 && second !== 0) ||\n      ((first !== 0 || second !== 0) && first === second)\n    );\n  }\n\n  /**\n   * checks whether current state of the field has tiles with zero value.\n   * @returns {boolean}\n   */\n  stateHasZeroes() {\n    return this.getState().some((line) => {\n      return line.some((cell) => cell === 0);\n    });\n  }\n\n  /**\n   * checks whether current state of the field has at least\n   * one case of tiles that can be merged\n   * @returns {boolean}\n   */\n  mergeIsPossible() {\n    const state = this.getState();\n\n    for (let i = 0; i < state.length; i++) {\n      for (let j = 0; j < state[i].length; j++) {\n        const current = state[i][j];\n        const right = state[i][j + 1];\n\n        if (right && current === right) {\n          return true;\n        }\n\n        if (i === state.length - 1) {\n          continue;\n        }\n\n        const below = state[i + 1][j];\n\n        if (below && current === below) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks if the current state of the field has any moves available.\n   * @returns {boolean}\n   */\n  checkIfLost() {\n    return !this.stateHasZeroes() && !this.mergeIsPossible();\n  }\n\n  /**\n   * Checks whether any cell line (1d array) has any moves available.\n   * @param {number[][]} state\n   * @returns {boolean}\n   */\n  checkAvailableMovesOnSingleLine(state) {\n    for (let i = 0; i < state.length; i++) {\n      for (let j = 0; j < state[i].length - 1; j++) {\n        const first = state[i][j];\n        const second = state[i][j + 1];\n\n        if (this.canMoveOrMergeCells(first, second)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Method updates current state of the game context with new values\n   * @param {object} keyValuePairObj\n   */\n  updateGameContext(keyValuePairObj) {\n    Object.entries(keyValuePairObj).forEach((entry) => {\n      const key = entry[0];\n      const value = entry[1];\n\n      this.gameContext[key] = value;\n    });\n  }\n\n  /**\n   * @param {number[][]} state - some form of state of the field\n   * @returns {number[][]} copy of the state reversed horizontally\n   */\n  reverseStateByAxis(state) {\n    return Array.from(state.map((line) => Array.from(line).reverse()));\n  }\n\n  /**\n   * Function calls relevant functions which may need to\n   * transpose and/or reverses state of the field\n   * depending on direction of the move\n   * @param {number[][]} state - some form of state of the field\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {number[][]} copy of updated state of the field\n   */\n  transformStatePerDirection(state, direction) {\n    switch (direction) {\n      case constants.DIRECTION.left: {\n        return state;\n      }\n\n      case constants.DIRECTION.right: {\n        return this.reverseStateByAxis(state);\n      }\n\n      case constants.DIRECTION.up: {\n        return this.transposeState(state, false);\n      }\n\n      case constants.DIRECTION.down: {\n        return this.transposeState(state, true);\n      }\n    }\n  }\n\n  /**\n   * Function transposes rows of the state of the field into columns.\n   * If needed, function reverses the lines of the transposed field.\n   * @param {number[][]} state - some form of state of the field\n   * @param {boolean} reverse - whether the transposed field should be reversed.\n   * @returns copy of the transposed/reversed state of the field.\n   */\n  transposeState(state, reverse = false) {\n    const transposeState = Array.from(state).map((line) => Array.from(line));\n\n    state.forEach((line, i) => {\n      line.forEach((cell, j) => {\n        transposeState[j][i] = cell;\n      });\n    });\n\n    return reverse\n      ? transposeState.reverse().map((line) => line.reverse())\n      : transposeState;\n  }\n\n  /**\n   * Function removes zeroes from the state of the field.\n   * @param {number[][]} state - some form of the state of the field\n   * @returns {number[][]} - copy of the the field without zero valued tiles\n   */\n  removeZeroes(state) {\n    return Array.from(state).map((line) => {\n      return Array.from(line).filter((num) => num !== 0);\n    });\n  }\n\n  /**\n   * Functions adds zeroes to empty tiles (after moves and merges are complete)\n   * @param {number[][]} state - some form of the state of the field\n   * @returns {number[][]} - copy of the field filled with 0 valued cells\n   */\n  fillWithZeroes(state) {\n    return Array.from(state).map((line) => {\n      if (line.length < constants.FIELD_SIZE) {\n        const updatedLine = Array.from(line);\n\n        updatedLine.length = constants.FIELD_SIZE;\n\n        return updatedLine.fill(0, line.length, constants.FIELD_SIZE);\n      } else {\n        return Array.from(line);\n      }\n    });\n  }\n\n  /**\n   * Function that processes:\n   * (1) move of non-zero tiles\n   * (2) merge of tiles\n   * (3) update score per turn\n   * (4) removes zeroes got as a result of merge\n   * @param {number[][]} state - some form of the field\n   * @returns {number[][]} - copy of the field with moved/merged cells\n   */\n  moveAndMergeTiles(state) {\n    const resultField = Array.from(state);\n    let score = 0;\n\n    for (let i = 0; i < state.length; i++) {\n      for (let j = 0; j < state[i].length - 1; j++) {\n        const current = state[i][j];\n        const next = state[i][j + 1];\n\n        if (current === 0) {\n          continue;\n        }\n\n        if (current === next) {\n          const mergeValue = current * 2;\n\n          if (mergeValue === constants.WIN_VALUE) {\n            this.updateGameContext({ status: constants.STATUS.win });\n          }\n\n          score += mergeValue;\n          resultField[i][j] = mergeValue;\n          resultField[i][j + 1] = 0;\n        }\n      }\n    }\n\n    const resultWithNoExtraZeroes = this.removeZeroes(resultField);\n\n    return { score: score, stateWithMergedTiles: resultWithNoExtraZeroes };\n  }\n\n  /**\n   * Function that selects proper move function\n   * depending on the direction of the move\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {function}\n   */\n  selectMoveFunction(direction) {\n    const functions = {\n      left: this.moveLeft.bind(this),\n      right: this.moveRight.bind(this),\n      up: this.moveUp.bind(this),\n      down: this.moveDown.bind(this),\n    };\n\n    return functions[direction];\n  }\n\n  /**\n   * Function that coordinates the procedure of the move\n   * @param {string} direction - 'left', 'right', 'up', 'down'\n   * @returns {boolean} true, if move succesfully processed\n   */\n  move(direction) {\n    // transform state (per X and Y axis) into convenient rows\n    const transformedState = this.transformStatePerDirection(\n      this.getState(),\n      direction,\n    );\n\n    // if move is not possible, move is not processed\n    this.updateGameContext({\n      movePossible: this.checkAvailableMovesOnSingleLine(transformedState),\n    });\n\n    if (!this.getGameContext().movePossible) {\n      return false;\n    }\n\n    // if move possible, remove zero tiles\n    const stateWithoutZeroes = this.removeZeroes(transformedState);\n\n    // merge tiles and calculate score\n    const { score, stateWithMergedTiles } =\n      this.moveAndMergeTiles(stateWithoutZeroes);\n\n    // empty tiles assigned with zero values\n    const updatedStateWithZeroes = this.fillWithZeroes(stateWithMergedTiles);\n\n    // re-transform X and Y axes back to their original state\n    const reTransformedState = this.transformStatePerDirection(\n      updatedStateWithZeroes,\n      direction,\n    );\n\n    // update game context with results of the move\n    this.updateGameContext({\n      score: this.getScore() + score,\n      state: reTransformedState,\n      moves: (this.getGameContext().moves += 1),\n    });\n\n    return true;\n  }\n\n  /**\n   * Function checks whether 4 valued cell should be added\n   * with certain probability (currently 10%)\n   * @returns {boolean}\n   */\n  isTimeForFourTile() {\n    return Math.random() < constants.PROBABILITY_FOR_FOUR;\n  }\n\n  /**\n   *\n   * @param {number} number\n   * @param {number} probability - number between 0 and 1\n   * @returns\n   */\n  randomlyChangeNumberWithProbability(number, probability) {\n    const random = Math.random();\n\n    return random < probability ? random : number;\n  }\n\n  /**\n   * Function analyses current state of the field and randomly adds\n   * a new cell with value of 2 (90% probability) or 4 (10% probability).\n   * Function is based on Reservoir Sampling algorithm.\n   * @returns {object} contains boolean field 'failedToAdd' and,\n   * in case of success, also contains row and col numbers and respective value.\n   */\n  addRandomCellValue() {\n    const state = this.getState();\n    const updatedField = Array.from(state).map((line) => Array.from(line));\n\n    let count = 1;\n    const probability = () => 1 / count;\n    let row = -1;\n    let col = -1;\n    let referenceRandom = -1;\n\n    for (let i = 0; i < state.length; i++) {\n      for (let j = 0; j < state[i].length; j++) {\n        if (state[i][j] !== 0) {\n          continue;\n        }\n\n        const random = this.randomlyChangeNumberWithProbability(\n          referenceRandom,\n          probability(),\n        );\n\n        if (random !== referenceRandom) {\n          referenceRandom = random;\n          row = i;\n          col = j;\n        }\n\n        count++;\n      }\n    }\n\n    if (row === -1 || col === -1 || updatedField[row][col] === undefined) {\n      return { failedToAdd: true };\n    }\n\n    const value = this.isTimeForFourTile() ? 4 : 2;\n\n    if (updatedField[row][col] === 0) {\n      updatedField[row][col] = value;\n      this.updateGameContext({ state: updatedField });\n\n      return {\n        failedToAdd: false,\n        row: row,\n        col: col,\n        value: value,\n      };\n    }\n\n    return { failedToAdd: true };\n  }\n}\n\nmodule.exports = Game;\n"],"names":["$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$ahdtQ","$8zzUU","$8HyT0","$09e991522ca7e64e$var$game","constructor","initialState","default","INITIAL_STATE","gameContext","state","score","status","STATUS","idle","movePossible","moves","moveLeft","move","DIRECTION","left","moveRight","right","moveUp","up","moveDown","down","getScore","getState","Array","from","map","line","getStatus","getGameContext","start","updateGameContext","playing","addRandomCellValue","restart","win","lose","getMoves","canMoveOrMergeCells","first","second","stateHasZeroes","some","cell","mergeIsPossible","i","length","j","current","below","checkIfLost","checkAvailableMovesOnSingleLine","keyValuePairObj","Object","entries","forEach","entry","key","value","reverseStateByAxis","reverse","transformStatePerDirection","direction","transposeState","removeZeroes","filter","num","fillWithZeroes","FIELD_SIZE","updatedLine","fill","moveAndMergeTiles","resultField","next","mergeValue","WIN_VALUE","stateWithMergedTiles","selectMoveFunction","functions","bind","transformedState","stateWithoutZeroes","updatedStateWithZeroes","reTransformedState","isTimeForFourTile","Math","random","PROBABILITY_FOR_FOUR","randomlyChangeNumberWithProbability","number","probability","updatedField","count","row","col","referenceRandom","undefined","failedToAdd","$09e991522ca7e64e$var$gameField","document","querySelector","$09e991522ca7e64e$var$scoreField","$09e991522ca7e64e$var$resetCellClassName","item","classList","remove","$09e991522ca7e64e$var$renderBoard","rows","fieldRow","cells","stateRow","newValue","innerHTML","add","$09e991522ca7e64e$var$renderCell","AddNewCellResult","$09e991522ca7e64e$var$startButton","$09e991522ca7e64e$var$restartButton","$09e991522ca7e64e$var$modificationsAfterFirstMove","switchButtons","makeMessageVisible","$09e991522ca7e64e$var$handleEndGameEvent","gameStatus","defocusField","$09e991522ca7e64e$var$removeMoveEventListeners","$09e991522ca7e64e$var$handleMoveEvent","promise","Promise","resolve","reject","moveFunction","then","message","console","log","setTimeout","catch","$09e991522ca7e64e$var$handleKeyDownEvent","e","targetKey","keyController","arrowKeys","hasOwnProperty","identifyArrowKeyDirection","$09e991522ca7e64e$var$handleSwipeEvent","swipeController","handleTouchEnd","$09e991522ca7e64e$var$addMoveEventListeners","addEventListener","handleTouchStart","preventScrollOnSwipe","removeEventListener","focusField"],"version":3,"file":"index.3eb5e11a.js.map"}